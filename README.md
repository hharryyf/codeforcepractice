# codeforce practice
codeforce practice summary update everyday

* Aug 30 to Sep8:


1. Rooks and Rectangles (div1, diff=2400, segmenttree and line sweep)
http://codeforces.com/problemset/problem/524/E

2. Cannon (div2, diff=2100, two pointers)
http://codeforces.com/problemset/problem/47/E

3. Buses and People (div2, diff=2400, segmenttree and line sweep)
https://codeforces.com/contest/160/problem/E

4. Summer Homework (diff=2500, segmenttree and math)
http://codeforces.com/problemset/problem/316/E3

5. Sum of Medians (diff=2200, segmenttree and divide and conquer)
https://codeforces.com/problemset/problem/85/D

6. Fire (div2, diff=2000, dynamic programming)
http://codeforces.com/problemset/problem/864/E

7. Package Delivery (div1/2, diff=2300, greedy)
https://codeforces.com/problemset/problem/627/C

8. Let Them Slide (div1/2, diff=2200, segmenttree and lazypropagation)
http://codeforces.com/problemset/problem/1208/E

9. Stripe 2 (codeforces round #21, diff=2300, dynamic programming)
http://codeforces.com/problemset/problem/21/C

10. Bulmart (2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest, diff=2200, greedy and binary search)
http://codeforces.com/problemset/problem/730/C

11. Preparing for the Contest (div1, diff=2100, greedy and binary search)
http://codeforces.com/problemset/problem/377/B

12. GukiZ hates Boxes (div2, diff=2200, greedy and binary search)
https://codeforces.com/problemset/problem/551/C

13. Stressful Training (div2, diff=2300, greedy and binary search)
http://codeforces.com/problemset/problem/1132/D

14. On Changing Tree (div1, diff=2400, segmenttree and dfs)
http://codeforces.com/contest/396/problem/C

* Sep 9 to Sep 16:


15. Frogs and mosquitoes (div2, diff=2500, segmenttree, greedy and set)
http://codeforces.com/contest/609/problem/F

16. Noise Level (div2, diff=2000, graph, bfs)
http://codeforces.com/contest/847/problem/I

17. Reachability from the Capital (div3, diff=1900, strongly connected component)
http://codeforces.com/contest/999/problem/E

18. Checkposts (div2, diff=1700, strongly connected component)
https://codeforces.com/contest/427/problem/C

19. Inna and Binary Logic (div2, diff=2400, segment tree and divide and conquer)
https://codeforces.com/contest/400/problem/E

20. Online Courses In BSU (VK Cup 2017 - Qualification 2, diff=1900, topological sort)
https://codeforces.com/contest/770/problem/C

21. The Child and Sequence (div2, diff=2300, segment tree and math)
https://codeforces.com/contest/438/problem/D

22. Closest Equals (VK Cup 2015 - Qualification Round 1, diff=2200, segment tree and sliding windows)
https://codeforces.com/contest/522/problem/D

23. One Occurrence (div2, diff=2400, segment tree and two pointers)
https://codeforces.com/problemset/problem/1000/F

24. Vasya and a Tree (div2, diff=1900, dfs definition and offline segment tree)
https://codeforces.com/problemset/problem/1076/E

25. Little Elephant and Tree (div1, diff=2400, dfs and offline segment tree)
https://codeforces.com/problemset/problem/258/E

26. Water Tree (div1, diff=2100, dfs and segment tree)
https://codeforces.com/contest/343/problem/D


* Sep 17 to Sep 23:

27. Buy a Ticket (div2, diff=2000, graph modification and dijkstra)
https://codeforces.com/contest/938/problem/D

28. 0-1-Tree (div2, diff=2300, tree DP) this problem needs more working on it!
https://codeforces.com/contest/1156/problem/D

29. Please, another Queries on Array? (div2, diff=2500, segment tree, bitset and math)
https://codeforces.com/problemset/problem/1114/F

30. Misha, Grisha and Underground (div2, diff=1900, math and lca using rmq)
https://codeforces.com/contest/832/problem/D

31. Kilani and the Game (div2, diff=1900, bfs) 
https://codeforces.com/problemset/problem/1105/D

32. Bertown roads (div2, diff=2100, tarjan's bridge finding algorithm)
https://codeforces.com/problemset/problem/118/E

* Sep 24 to Sep 30:

33. Scheme (div2, diff=2400, tarjan's scc and point compression)
https://codeforces.com/contest/22/problem/E

34. Roads not only in Berland (div2, diff=1900, Kruskal MST)
https://codeforces.com/problemset/problem/25/D

* Oct 1 to Oct 7:

35. Legency (div1, diff=2600, segment tree and dijkstra)
https://codeforces.com/problemset/problem/786/B

36. Paths and Trees (div2, diff=2100, dijkstra)
https://codeforces.com/problemset/problem/545/E

37. st- spanning tree (div2, diff=2200, kruskal and greedy)
https://codeforces.com/problemset/problem/723/F

38. Queue (Codeforces Beta Round, diff=2300, AVL tree)
https://codeforces.com/contest/38/problem/G

* Oct 8 to Oct 13:

39. The Shortest Statement (div2, diff=2300, dijkstra and LCA) 
https://codeforces.com/problemset/problem/1051/F

40. Strictly Positive Matrix (div2, diff=2200, tarjan scc and math)
https://codeforces.com/problemset/problem/402/E

41. Analysis of Pathes in Functional Graph (div2, diff=2100, binary lifting) 
https://codeforces.com/problemset/problem/702/E

42. We Need More Bosses (div2, diff=2100, tarjan and tree dp)
https://codeforces.com/problemset/problem/1000/E

* Oct 14 to Oct 20:

43. Beautiful numbers (div2, diff=2400, dight dp)
https://codeforces.com/problemset/problem/55/D

44. Magic Numbers (div2, diff=2200, digit dp)
https://codeforces.com/problemset/problem/628/D

45. Roman and Numbers (div2, diff=2000, digit dp and bitmask)
https://codeforces.com/problemset/problem/401/D

46. Segment Sum (div2, diff=2300, digit dp and bitmask)
https://codeforces.com/problemset/problem/1073/E

* Oct 21 to Oct 27:

47. Ilya and Roads (div2, diff=2100, DP and greedy)
https://codeforces.com/problemset/problem/313/D

48. Lunar New Year and Red Envelopes (div2, diff=2100, DP and line sweep)
https://codeforces.com/problemset/problem/1106/E

49. Sequence (Codeforces Beta Round #13, diff=2200, DP)
https://codeforces.com/contest/13/problem/C

50. Bad Luck Island (div2, diff=2100, DP and probability)
https://codeforces.com/contest/540/problem/D

51. Linear Kingdom Race (div1, diff=2400, DP and segment tree and line sweep)
https://codeforces.com/contest/115/problem/E

52. Trains and Statistic (div2, diff=2500, DP and segment tree and greedy) 
https://codeforces.com/contest/675/problem/E

53. Bear and Tree Jumps (VK Cup 2017 - Round 1, diff=2100, tree DP)
https://codeforces.com/problemset/problem/771/C

* OCt 28 to Nov 3:

54. Coloring Brackets (div2, diff=2200, interval DP) 
https://codeforces.com/contest/149/problem/D

55. Periodic RMQ Problem (Educational Codeforces Round 20, diff=2500, segment tree and point compression)
https://codeforces.com/contest/803/problem/G

* Nov 17 to Nov 24:

56. Cow (Poj2481, line sweep and fenwick tree)
https://vjudge.net/problem/POJ-2481

57. Stars in Your Window (Poj2482, line sweep and segment tree lazy propagation)
https://vjudge.net/problem/POJ-2482

58. Camping Groups (Croc Champ 2012 - Round 1, line sweep & fenwick tree & segment tree, diff=2600)
https://codeforces.com/contest/173/problem/E

* Nov 25 to Dec 11:

59. A and B and Lecture Rooms (div2, diff=2300, LCA and dfs)
https://codeforces.com/contest/519/problem/E

60. Road Improvement (div1, diff=2300, dp // worst problem I've ever seen)
https://codeforces.com/problemset/problem/543/D

61. Little Elephant and Inversions (div1, diff=2400, fenwick tree and line sweep) 
https://codeforces.com/contest/220/problem/E

62. Yaroslav and Divisors (div1, diff=2200, fenwick tree and line sweep) 
https://codeforces.com/contest/301/problem/D

63. Bear and Bowling 4 (Educational Codeforces Round 11, diff=2500, convex-hull and dp)
https://codeforces.com/contest/660/problem/F

64. Tree (div1 + div2, diff=2200, binary-lifting and dp) 
https://codeforces.com/contest/932/problem/D

65. Send the Fool Further! (medium) (Helvetic Coding Contest 2017, diff=2100, tree dp) 
https://codeforces.com/contest/802/problem/K

66. Tree with Maximum Cost (div3, diff=2100, tree dp)
https://codeforces.com/contest/1092/problem/F

* Dec 12 to Feb 11 summer holiday training --- data structure + graph + string  

67. Dog Food (div2, diff=2300, greedy)
https://codeforces.com/contest/847/problem/D

68. Berland University (diff=2100, greedy and binary search)
https://codeforces.com/contest/1090/problem/L

69. Complete The Graph (diff=2200, dijkstra)
https://codeforces.com/problemset/problem/715/B

70. Three States (diff=2200, dijkstra)
https://codeforces.com/problemset/problem/590/C

71. Case of Chocolate (diff=2500, range tree)
https://codeforces.com/problemset/problem/555/C

72. REQ (diff=2500, range tree and sweeping and number theory)
https://codeforces.com/problemset/problem/594/D

73. Wires (diff=2200, graph and dfs)
https://codeforces.com/problemset/problem/1250/N

74. Petya and Graph (diff=2400, Dinic's algorithm and maximum enclosure graph)
https://codeforces.com/problemset/problem/1082/G

75. Jeff and Removing Periods (diff=2700, fenwick tree, line sweep)
https://codeforces.com/contest/351/problem/D

76. Soldier and Traveling (diff=2300, Dinic's algorithm and extracting flow)
https://codeforces.com/contest/546/problem/E

77. Exploration plan (diff=2400, Dinic's algorithm and Floyd algorithm and binary search for final answer)
https://codeforces.com/problemset/problem/852/D

78. Valera and Queries (diff=2400, fenwick tree, line sweep)
https://codeforces.com/problemset/problem/369/E

79. Minimal Labels (diff=2400, greedy and topological sort)
https://codeforces.com/problemset/problem/825/E

80. Diverging Directions (diff=2100, LCA and range tree and dfs)
https://codeforces.com/problemset/problem/838/B

81. Flipping Frustration (extended euclidian algorithm)
https://vjudge.net/problem/UVA-11312

82. Airport Express (dijkstra, path construction)
https://vjudge.net/problem/UVA-11374

83. Drivers Dissatisfaction (diff=2500, Kruskal, greedy, LCA)
https://codeforces.com/contest/733/problem/F

84. Tourist Reform (diff=2400, tarjan's algorithm, bridge finding and biconnected component)
https://codeforces.com/contest/732/problem/F

85. Robots in a DAG (codechef, Dinic's algorithm, construct flow graph in stages)
https://www.codechef.com/problems/ROBOTDAG

86. The K-League (uva, Dinic's algorithm, allocation problem)
https://vjudge.net/problem/UVA-1306

87. Gripping Story (diff=2400, range tree, amortized complexity and searching)
https://codeforces.com/problemset/problem/198/E

88. Radio stations (diff=2400, line sweep and dynamic range tree)
https://codeforces.com/problemset/problem/762/E

89. Developing Game (diff=2400, line sweep and range tree, solved after reading solutions, problem reduction part is stunning)
https://codeforces.com/contest/377/problem/D

90. Army Creation (diff=2300, persistent range tree)
https://codeforces.com/problemset/problem/813/E

91. Board Game (diff=2400, range tree searching, BFS) 
https://codeforces.com/problemset/problem/605/D

92. DQUERY (spoj, Mo's algorithm (range tree/fenwick tree definitly works but Mo's algorithm is excited))
https://vjudge.net/problem/SPOJ-DQUERY

93. Tree and Queries (diff=2400, Mo's algorithm)
https://codeforces.com/contest/375/problem/D

94. Tempter of the Bone (hdu, dfs and backtracking and pruning)
https://vjudge.net/problem/HDU-1010

95. Hot is Cold (diff=2400, range tree and 2-tag lazy propagation, exactly the same technique as codeforce817f MEX query)
https://codeforces.com/problemset/problem/1146/E

96. K-th Number (poj, persistent range tree, searching)
https://vjudge.net/problem/POJ-2104

97. George and Cards (diff=2500, sparse table and fenwick tree and binary search)
https://codeforces.com/contest/387/problem/E

98. Destiny (diff=2400, persistent range tree finding kth largest number and observation)
https://codeforces.com/problemset/problem/840/D

99. Startup Funding (diff=2400, binary search and sparse table and probability)
https://codeforces.com/problemset/problem/633/E

100. Traffic Jams in the Land (diff=2400, range tree, divide and conquer, math observation)
https://codeforces.com/contest/498/problem/D

101. Fire in the City (diff=2500, line sweep and binary search for final answer)
https://codeforces.com/contest/845/problem/E

102. Yet Another Multiple Problem (2012 chengdu regional contest, BFS on numbers)
https://vjudge.net/problem/UVA-1653

103. Angry Programmer (uva, a very simple max flow problem on vertex capacity)
https://vjudge.net/problem/UVA-11506

104. Sorting It All Out (poj, uniqueness of top-sort)
https://vjudge.net/problem/POJ-1094

105. A Famous Grid (spoj, SIEVE and BFS, create a larger grid to deal with the walk out case!)
https://vjudge.net/problem/SPOJ-SPIRALGR

106. Mushroom Gnomes - 2 (diff=2500, range tree and probability)
https://codeforces.com/contest/138/problem/C

107. Following Orders (uva, top-sort BFS approach with backtracking, extracting all top-sort order in dictionary order, good template)
https://vjudge.net/problem/UVA-124

108. Nastya and King-Shamans (diff=2600, range tree and pruning, learned a valuable lesson in time complexity analysis)
https://codeforces.com/contest/992/problem/E

109. Functions on the segments (diff=2600, persistent range tree, solved after getting feedback for 9 times! Note that if only single point value is required we don't need lazy tag!)
https://codeforces.com/contest/837/problem/G

110. Hanger (diff=2300, set and fenwick tree)
https://codeforces.com/problemset/problem/74/D

111. Trip to Saint Petersburg (diff=2300, line sweep and range tree and lazy porpagation, this problem is similar to 115E linear kingdom race)
https://codeforces.com/problemset/problem/1250/C

112. Choose a Square (diff=2500, line sweep and range tree and lazy propagation, another problem similar to 115E linear kingdom race)
https://codeforces.com/contest/1221/problem/F

113. Parking Lot (diff=2500, set and implementation)
https://codeforces.com/problemset/problem/219/E

114. The doors (uva, simple geometry and bellman-ford algorithm, remember the special case for judging two intervals intersection)
https://vjudge.net/problem/UVA-393

115. Queue in the Train (diff=2300, line sweep and priority queue optimization, how to order the event is very important)
https://codeforces.com/contest/1239/problem/C

116. Heidi and the Turing Test (Medium) (diff=2300, line sweep and range tree, change the coordinate system)
https://codeforces.com/problemset/problem/1184/C2

117. Performance Review (diff=2300, range tree and lazy propagation, key observation: the value itself is useless, only >, < matters)
https://codeforces.com/contest/1252/problem/G

118. King Kog's Reception (diff=2400, range tree and divide and conquer)
https://codeforces.com/contest/1089/problem/K

119. Cave Raider (bellman-ford algorithm, shortest path with constraints on path entry time)
https://vjudge.net/problem/POJ-1613

120. Segment Tree (diff=2100, graph connectivity, union find, range tree, complexity analysis, sweeping)
https://codeforces.com/contest/1278/problem/D

121. Find a Number (diff=2200, BFS on remainder, same trick as "Yet Another Multiple Problem")
https://codeforces.com/problemset/problem/1070/A

122. More Queries to Array... (diff=2600, range tree and lazy propagation and binomial theorem)
https://codeforces.com/problemset/problem/266/E

123. Connected Components? (diff=2100, dfs and union-find and range tree to create the graph)
https://codeforces.com/contest/920/problem/E

124.  Bear and Forgotten Tree 2 (diff=2400, dfs and union-find and range tree graph creation, similar to the previous one just with more observation) 
https://codeforces.com/contest/653/problem/E

125. Shortest Path (diff=2100, shortest path, some trick when doing relaxation)
https://codeforces.com/contest/59/problem/E

126. Greedy Elevator (diff=2500, fenwick tree and set, good implementation problem)
https://codeforces.com/contest/257/problem/E

127. Intervals (uva, system of different constraints)
https://vjudge.net/problem/UVA-1723

128. Sereja and Straight Lines (diff=2400, binary search for final answer and line sweep, similar to 845E and 1184C2)
https://codeforces.com/contest/314/problem/D

129. King (central Euro 1997, system of different constraints)
https://vjudge.net/problem/POJ-1364

130. XOR and Favorite Number (diff=2300, Mo's algorithm, need to be very clear on what [l, r] means when maintaining prefix sum)
https://codeforces.com/contest/617/problem/E

131. Cutting a Fence (diff=2400, probability and range tree and lazy propagation on arithmetic progression)
https://codeforces.com/contest/212/problem/D

132. Little Elephant and Shifts (diff=2300, map and math observation)
https://codeforces.com/problemset/problem/220/C

133. Powerful Array (diff=2700, Mo's algorithm)
https://codeforces.com/contest/86/problem/D

134. Serega and Fun (diff=2600, sqrt decomposition, I'm not familiar with deque STL access method which caused me getting WA feedback for 4 times)
https://codeforces.com/contest/455/problem/D

135. Music in Car (diff=2500, line sweep and sets, I think this problem requires some implementation techniques, for example creating
two structs instead of using functions to handle the time addition event would make our life a lot easier)
https://codeforces.com/contest/746/problem/F

136. Play on Words (central Europe, union find and Euler path existence checking, I think the most important observation is using words as "edges" of the graph) https://vjudge.net/problem/UVA-10129

137. Cardboard Box (diff=2500, greedy and fenwick tree, I was killed by this problem :( )
This problem requires the following greedy observation, suppose that an optimal solution has the maximum b[k] at index k, then
we could proof that all [1:k] have been selected at least for level 1. Then the problem is quite routine, using fenwick tree and
binary search would easily give a solution of O(n*logn*logn).
https://codeforces.com/contest/436/problem/E

138. Catenyms (least alphabetical ordered Euler path and Hierholzer's algorithm)
https://vjudge.net/problem/UVA-10441

139. Bear and Contribution (diff=2500, greedy and priority queue)
I wasted valuable time because of ignoring the fact that the final T can be a number not in the given array.
This problem has a very trivial greedy observation which is we need to select k numbers that has the minimum cost to increase
them to T. However, we need to be aware how to maintain a window of k numbers with minimum cost, using priority queue here is
definitly the best choice. https://codeforces.com/contest/639/problem/D

140. Working routine (diff=2600, linked list)
This problem requires some implementation technique, firstly since n = 1000, m = 1000 and q = 10000, we know that O((m+n)q) is
good enough to pass the tests. Note that swapping two submatrix only require to change the connection links. Hence, linked-list
is the best data structure for this type of query. https://codeforces.com/contest/706/problem/E

141. Donkey and Stars (diff=2600, line sweep and geometry and range tree)
This problem taught me some valuable lessons even if I solved it without the support of any solutions. 1. when we are solving
geometry problems, use "/" as few as possible to eliminate TLE. 2. pair<int, index (int)> would be more efficient than pair<int, object> when making a pair. Beyond that, this problem is still very nice. We firstly changed the problem to a LIS problem by math observation,
and after that since the > is defined by two conditions, we can use the standard trick of range tree and line sweep to solve it.
https://codeforces.com/contest/249/problem/D

142. Trips (diff=2100, graph connectivity, working backward and sets)
This graph problem is very interesting. The key observation is when i increases from 1 to m, the tourist set size can only increase.
Hence, we can work backward, firstly add in all the edges. Then, we delete all the edges one by one and always see whether there's an
element with degree less than k, if so eliminate the element. https://codeforces.com/problemset/problem/1037/E

143. Bribes (diff=2300, dfs and LCA and prefix sum)
I got WA for 3 times because of solving a different problem! There's an obvious observation that we only need to know how many times
each road is used. Hence, we use the prefix sum technique that was used in on changing tree.

144. World Tour (diff=2100, BFS and path construction)
This problem has the following observation. If you fix the 2nd and 3rd point, we only need to find the valid 1st and 4th point,
with maximum dist(1, 2) + dist(3, 4) + dist(2, 3). Hence, we can run a BFS to find the pair-wise shortest path, then we might realize
that maximum dist(1, 2) and dist(3, 4) might contain duplicate points (e.g. pt(1) == pt(3)) which is invalid, we need to record
3 points i with maximum distance dist(i, v) / dist(v, i) for each v. https://codeforces.com/contest/666/problem/B

145. Ratings and Reality Shows (diff=2500, range tree and divide and conquer)
I got WA for 4 times and fixed the code for 1.5 hours because of a long long :( . This problem could be solved by using range tree
and divide and conquer. The observation is we only need to make sure the following two values are not less than 0: 1) start +
min_prefix up to t 2) start + prefix up to t + range min sum start from t end at t + len - 1. 
https://codeforces.com/contest/887/problem/D

146. Polycarp and Hay (diff=2100, union-find and dfs)
The observation is since there is a number that must be fixed, we can sort the numbers in the grid which are factors of k in decreasing
order, then the problem is reduced to determine whether there exists a connected component which contains no less than k / g[i][j] numbers, then a union-find and dfs would simply do the job. https://codeforces.com/contest/659/problem/F

147. MST Unification (diff=2300, Kruskal and LCA, binary lifting)
The trick Ray covered in the problem set on MST is very useful. I've already solved more than 3 problems using this trick.
https://codeforces.com/contest/1108/problem/F

148. Optimal Milking (binary search for final answer, Dinic's algorithm)
This problem is similar to codeforce852d, we firstly preprocess all the pair-wise shortest path using Floyd algorithm. Then we binary
search the final answer and use Dinic's algorithm to validate. https://vjudge.net/problem/POJ-2112

149. Panic Room (min-cut)
This problem is very easy. It just asks whether some vertices can all be seperated from a given sink. Add a super source and connects
to all the vertices need to be seperated with INF, connect the forward edges with capacity 1 and backward edges with capacity INF. Then
just run Dinic's algorithm would find the solution. https://vjudge.net/problem/UVALive-3632

150. Cup Trick (diff=2500, balanced tree)
The observation for this problem is there are two cases the task cannot be fulfilled. 1) when you try to move the kth position cup i
to the front, there's a cup j != i at position k. 2) the ith cup is at some other location. Hence, we need to design a data structure
that supports the following 1) insert an element 2) delete an element 3) find the kth smallest element. Any type of balanced tree would
work. However, ordered statistic tree is very slow :(, I wrote an AVL tree and used some fast io techniques to pass the tests.
https://codeforces.com/contest/420/problem/D

151. Kaka's Matrix Travels (MCMF)
This problem verifies the correctness of the MCMF template. Since all points can be walked trough k times, with 1 time that can achieve 
the profit, we set each vertex with a vertex capacity of 1 and vertex cost of v. Then run the MCMF algorithm would find the solution.
https://vjudge.net/problem/POJ-3422

152. Going Home (MCMF)
https://vjudge.net/problem/UVALive-3198

153. Build String (diff=2100, MCMF)
This problem is quite easy. Just add nodes to represent sentences and connect the source to it with cap=a[i] and cost=0,
add the sentence to the a-z nodes with the word count and cost=i, then add the a-z nodes to the target with cost=0, cap=target_cnt.
https://codeforces.com/contest/237/problem/E

154. Binary Tree on Plane (diff=2400, MCMF)
This is the kind of problem we think it is impossible to be done without flow. If we think this might be a flow problem, we have 
the following observation. For a binary tree, each node has at most 2 outlink and at most 1 in link. And for n points if it is a
tree, it must have n-1 points with 1 in link. Hence, we can create the flow graph as follows, add edges with cap 2 and cost 0,
from the super source to all the in vertices, add edges with cap 1 and cost equals to the Euclidian distance from the in vertices
to the out vertices that below them, finally add edges with cap 1 and cost 0 from the out vertices to the super sink. Run MCMF would
give the correct solution. https://codeforces.com/problemset/problem/277/E

155. Olympiad in Programming and Sports (diff=2200, MCMF)
I don't know how to solve this problem using an O(n^2) dp, hence, I'm using MCMF to solve it. The flow establish process looks as
follows. Add a super source connects to all 1-n person with cap 1 cost 0, add all 1-n person to the node n+1 with cap 1 cost a[i],
similarly to n+2 with cap 1 cost b[i]. Finally connects n+1 to super sink with cap p cost 0 and n+2 to super sink with cap s cost 0.
Run MCMF and extracting all the full capacity edges in the flow network. https://codeforces.com/contest/730/problem/I

156. Chemistry Experiment (diff=2500, fenwick tree and binary search for final answer)
We use binary search on final answer to solve this problem. We can ask the following question, is it possible for the maximum height to be less than h. Then we observe that only the tubs with height <= h can contribute to the final answer. Suppose that there are cnt tubes with height <= h and the total amount of mercury in them is vol, then we only need to check whether h * cnt >= v + vol.
We might run into precision issue since v can be up to 1e15. We just iterate 80 times to get the answer. The overall complexity would be O(nlognlogv).  https://codeforces.com/contest/431/problem/E

157. Air Raid (theorem: |V| = bipartite matching + minimum edge cover)
https://vjudge.net/problem/UVA-1184

158. Pursuit For Artifacts (diff=2300, tarjan's algorithm and dfs)
By definition of biconnected components, for any two points u, v in the same biconnected components there exists at least 2
path from u->v. Hence, we have the following observation. If there's some artifects in some biconnected components if we can
get in to the components, we can definitly get out in any points we want. So the algorithm works as follows. Firstly, run tarjan's
algorithm to extract all the biconnected components and do point compression to make the graph into a tree. Then the problem
is changed into whether there is a special vertex or an special edges in two given points in a tree. Validating the path u->LCA(u, v)
->v would get the solution. https://codeforces.com/problemset/problem/652/E

159. Segments (diff=2500, sets)
Nothing special about the problem, just maintain a set of disjoint segments to achieved an armotized O(logn) intertion complexity.
https://codeforces.com/contest/926/problem/J

160. Dispute (diff=2100, BFS)
We have the following observation, there's no -1 case, since for every button we only need to press at most once to make the button valid. Hence, we can use BFS by pushing all buttons with value 0 into the queue, and then press the corresponding buttons. 
https://codeforces.com/problemset/problem/242/D

161. Students Initiation (diff=2400, Dinic's algorithm and binary search for final answer)
We can observe that if we define the question as can the final answer be no greater than mid. Then we should easily show that if mid1
satisfy the problem statement then mid2 >= mid1 can definitly satisfy the statement. Hence, we can binary search for final answer.
Note that we can solve this problem by applying maxflow algorithms. Suppose that we want to validate mid, we add edges from the super
source to all n people with edge capacity mid, then suppose that the ith edge has end points v1 and v2, we add edge from v1 to i+n and
v2 to i+n with capacity 1, and finally add edges from the nodes representing edges to the super sink. We just need to validate whether
the final flow is m. The flow network is similar to Ray's problem set question Hard life which again proofs Ray's problem set is
very useful. https://codeforces.com/contest/847/problem/J

162. Take-off Ramps (diff=2400, point compression and dijkstra's algorithm)
The hardest part about this problem is dealing with the p[i]. We build the graph in the following way, firstly note that only
x[i], x[i] + d[i], x[i] - p[i], 0, L are useful points, we connect the adjacent points x1, x2 with weight x2 - x1 bidirectionally. 
A key observation is if we use the ramp i, it is actually equivalent to running from x[i] - p[i] to x[i] using p[i] time and then fly from x[i] to x[i] + d[i] in t[i]. So we can directly connect x[i] - p[i] to x[i] + d[i] with weight t[i] + p[i]. After that, we simply
run dijkstra's algorithm and find the solution. https://codeforces.com/contest/141/problem/D

163. Almost Permutation (diff=2300, MCMF)
Firstly, we can use elimination method to find out for each element at index i, which element can be filled in it. Then, the problem
is changed to for each index select a matching element, and for each element the cost of selecting it is cnt^2. This is a typical MCMF
problem setting. We connects the super source to 1-n and then if the ith element can have a value j we connect i to j+n. Finally, 
we connect 1+n to 2n to the super sink with (cap,cost) of (1, 1), (1,3)...(1, 2n-1). Then run the MCMF to find the solution.
https://codeforces.com/problemset/problem/863/F

164. Card Game (diff=2500, Dinic's algorithm and binary search for final answer)
I was coached by this problem :(. This problem requires 3 observations, 2 of them are quite standard. Firstly, we observe that we can use binary search on final answer to solve this problem. Secondly, min cut on a bipartite graph can validate the answer. However, how can we establish the bipartite graph? The key observation is only 2 = 1 + 1 is the only even prime number, so that we can split the numbers into LHS (all odd numbers), and RHS (all even numbers). For 1, we only keep the one which is valid at the moment and has the maximum p value. Then we simply run any maxflow algorithm would find the solution. https://codeforces.com/contest/808/problem/F

165. Eyes Closed (diff=2500, range tree and probability)
We know that E[l1, r1] = E[l1, r1] * (len1-1) / len1 + E[l2, r2] / len2 and E[l1, r1] = E[l2, r2] * (len2-1) / len2 + E[l1, r1] / len1.
Hence, the problem is changed into a range update and range query problem, a standard range tree would solve it easily. We only need to be careful about the order of lazy propagation. https://codeforces.com/contest/895/problem/E

166. Guess Your Way Out! II (diff=2500, sets)
The observation is we can deal with 1 events and 0 events seperately. For all 1 events, it is like intersection the answer ranges,
for all 0 events, we union the invalid ranges. To maintain the 0 events, we maintain a set of disjointed pairs which support insertion.
After the intersection 1 event range is determined, we do ans = ans - invalid. Note that here, ans and invalid are sets.
https://codeforces.com/contest/558/problem/D

167. Number Sequence (KMP)
https://vjudge.net/problem/HDU-1711

168. Oulipo (KMP)
The hardest part about this problem is overlap counts. Hence, we need to make good use of the next array. Since next is defined as
the longest match of the suffix and the prefix, by drawing some diagrams we can easily figure out that when there's a match, we
simply shift j to next[j-1] and i-- would solve the problem. https://vjudge.net/problem/HDU-1686

169. Cyclic Nacklace (KMP)
The observation is we only need to work out the shortest period prefix of a string. And the period is equal to len - next[len] after
we work out next array using KMP. https://vjudge.net/problem/HDU-3746

170. Period (KMP)
https://vjudge.net/problem/SPOJ-PERIOD

171. Kefa and Watch (diff=2700, range tree and hashing)
A range update should immediately remind us to use range trees. And to answer whether a string of length n has a period of d we know from the KMP algorithm, this is equivalent to checking the substring [1:len-d] is equal to [d+1, len]. To do this is an efficient way,
we could use hash functions. Two strings are called equal if their hash function is equal and in order to get the correct answer with
very very high probability, we can use two hash functions, then the strings are equal if both functions are equal. After that, the
problem is changed into a routine range tree and lazy propagation problem. https://codeforces.com/contest/580/problem/E

172. Power Strings (KMP)
https://vjudge.net/problem/UVA-10298

173. Seek the Name, Seek the Fame (KMP)
This problem examines the understanding of the next array of the KMP algorithm. We can find the next array first and backtrack the 
answer by calling curr = nxt[curr]. https://vjudge.net/problem/POJ-2752

174. Nudist Beach (diff=2300, BFS and binary search for final answer)
The first observation is if we rephrase the question as is it possible for the final answer to be no less than v (0 <= v <= 1), 
we immediately notice that v is monotone. Hence, we can binary search for the final answer. However, another difficulty is how
to create a set of nodes that satisfy the constraints. The most important observation is if we remove the neighbour of a node v,
its strength can only decrease. Hence, we can use BFS strategy and eliminate all nodes that have strength less than v. The main lesson
here is if you cannot construct the answer in a forward direction, try to do it backward. https://codeforces.com/contest/553/problem/D

175. Fools and Foolproof Roads (diff=2500, greedy and union find)
https://codeforces.com/contest/362/problem/D

176. Okabe and City (diff=2200, dijkstra)
This is a standard problem about using dijkstra on state transition. For every point, we consider 3 states, 0 = no light, 1= the row
is lit, 2= the column is lit, then just follow the problem statement to do valid state transition. https://codeforces.com/problemset/problem/821/D

177. Teams Formation (diff=2400, deque and observation)
The key observation is only 4 types of group can be formed. Type 1: groups that are formed by k adjacent unique elements in 1 period, this kind of group should be counted m times for each occurence in the original sequence of length n. Type 2: after groups of type 1 are formed,  groups can be formed by the starting elements of period i+1 and ending elements of period i. And this kind of group should be
counted m-1 times for each occurence of the original sequence. Type 3: if there's a unique remaining elements, new groups that contains
only this element can be formed. Type 4: if there's no remaining elements after the first 3 types of group are formed, the total number
of type 2 should be counted twice (see the last input data). https://codeforces.com/problemset/problem/878/B

178. Spanning Tree with One Fixed Degree (diff=2200, union find)
This is a constructive problem. We firstly join all the points with index greater than 1 without edges that have 1 as an endpoint. 
Then, we join 1 with all connected components once. For the remaining degree, we join 1 with all the connected points that weren't joined in the previous step. Finally, we use union find again on the remaining edges to create the final tree.
https://codeforces.com/contest/1133/problem/F2

179. Mr. Kitayuta's Colorful Graph (diff=2300, union find and observation)
We can consider each color seperately, u can reach v in an undirected graph means if we apply union find procedure, u and v should
end up in the same connected component. Hence, we can establish n sets, for the set i, it records all (p, c) pairs which means
i belongs to the connected component p with color c. Note that to avoid TLE, we only append (p, c) to set i if there's edge(u, i, c)
or edge(i, u, c). After that for each query, it simply asks the size of the intersection of set(u) and set(v), we iterate the 
set with a smaller size to answer the queries. https://codeforces.com/contest/506/problem/D

180. Desk Disorder (diff=2100, union find)
There are only 3 types of connected components, tp1: connected components that forms a functional graph, tp2: connected components
that forms a tree, tp3: connected components with self cycle. For case 1, the ans sould be doubled, case 2, ans could time the number
of vertices in such connected component. Since every vertex has at most 1 outlink, union find can help to detect cycle and self cycle
in this situation. https://codeforces.com/problemset/problem/859/E

181. New Roads (diff=2100, tree and observation)
The problem asks to construct a tree satisfies the ith level consists a[i] nodes and there are k leaf nodes. The key observation is
for every level from 0 to t-1, there must be at least 1 non leaf node and if a[i] > a[i+1], level i must have at least a[i] - a[i+1]
leaf nodes. We can mark the nodes that must be leaf node first and then link the edges. https://codeforces.com/problemset/problem/746/G

182. Place Your Ad Here (diff=2500, line sweep, range tree, set)
The problem asks to compute the largest cost[j] * intersection(interval of type 1, interval of type 2). We can easily classify it as
a line sweep problem. We should do 3 line sweeps in total. The first sweep, we eliminate all the channels that can be fully overlapped
by the videos using a set and update the answer. The second line sweep, we sort all the channels and videos by the r value and
use a range tree to update the answer. Finally, we sort all the channels and videos by the l value and use a range tree to update the
answer. https://codeforces.com/contest/542/problem/A

183. Breaking Good (diff=2200, BFS and dijkstra)
The problem is equivalent to finding the shortest path that has the most amount of 1 edge (i.e. shortest path that has the least amount of 0 edge). We can run 2 BFS first, one from vertex 1, the other from vertex n. Then, we construct a shortest path level graph with k[i] as weights. Finally, we run dijkstra's algorithm to find the shortest weighted path from 1 to n in the level graph we created in the previous step. https://codeforces.com/contest/507/problem/E

184. Information Graph (diff=2400, offline union find)
This problem is very similar to one of Ray's assignment problem. Asking whether x has a type i document is equivalent to asking,
whether at the time document i is signed whether x is the parent of y (the person that initially signed the document). This can
be done efficiently by sorting the queries according to the type-2 event. And then we do a line sweep, for each type-1 event, we union
point x and point y, for each type-3 event we simply see whether x and y is in the same connected component and y is in the subtree
of x. https://codeforces.com/contest/466/problem/E

185. Almost Acyclic Graph (diff=2200, dfs)
This examines the definition of backedge in dfs traversal. https://codeforces.com/contest/915/problem/D

186. Andrew and Taxi (diff=2200, binary search for final answer and top-sort)
The problem is actually asking select the minimum C, such that we only need to select edges with weight less than or equal to C
and reverse some in order to eliminate all the cycles in the graph. We can binary search on this C. However, how to validate the
final answer is quite tricky. Something we might ignore is if we do a top sort on an acyalic graph, if we keep adding edges from
some v1 to v2 which v1 has a top order less than v2, the graph would never contain a cycle. Hence, we can simply find the top
order of the subgraph formed with edges with weight greater than C, and add the remaining edges from a vertex with less top sort order 
to a vertex with greater top sort order. https://codeforces.com/problemset/problem/1100/E

* Feb 12 to Mar 11 --- "virus gap term training" focal point: dynamic programming, greedy and graph

187. Suggested Friends (diff=2200, graph connectivity and brute force)
If we cannot solve the problem if a smart way, the first thing we need to do is analyze the complexity of brute force. And we can see
if we just follow the definition of suggested friend we have a solution that is O(m^2) which m <= 5000, hence the brute force solution would run in time. https://codeforces.com/contest/245/problem/G

188. Tourism (diff=2200, tarjan's algorithm and simple tree dp)
The statement "not use any road twice in a row" should immediately remind us to use tarjan's bridge finding algorithm to compress
the biconnected components into a tree. However, there's something we have to be careful before run a simple tree dp to find the
largest weighted path from root to leaf. If a component size has size greater than 1 and one of its child has component size greater
than 1, one can actually walk down to the child and come back. Hence, in order to reduce the complexity of the dp procedure, 
if a biconnected component has size greater than 1, we recursively merge it to its parent. https://codeforces.com/problemset/problem/1220/E

189. Fishes (diff=2100, priority queue and expected value)
The answer is actually the sum of the k cells that has the largest total contribution. If we draw some examples we can figure out that
these k cells should group together, hence we can use a priority queue and a uninformed cost search that starts from (r, r) to 
find the k largest contributing cells. https://codeforces.com/problemset/problem/912/D

190. Roma and Poker (diff=2100, standard dp)
https://codeforces.com/contest/803/problem/E

191. Counter Attack (diff=2300, union find and range tree graph construction)
Similar to 653E, nothing special. https://codeforces.com/contest/190/problem/E

192. Tree Constructing (diff=2200, graph, construction)
There's an obvious observation, we can construct one diameter first and then add subtrees to the vertices on that diameter.
https://codeforces.com/contest/1003/problem/E

193. Iahub and Xors (diff=2500, 2d-fenwick tree)
I learned something new on 2d data structure :). https://vjudge.net/problem/CodeForces-341D

194. Anti-Palindromize (diff=2500, MCMF)
It is quite obvious that the problem is not a dp problem, so maxflow or MCMF should be our direction. The problem basically has
several constrains, for each letter is should be used exactly cnt_i times, for each position should match exactly 1 letter,
position i and position n-i+1 should have different letters. We can construct the following graph, connect src to nodes representing
a-z with cap= cnt_i, cost=0, create n/2 extra nodes for each letter (a-z), connect a-z to these extra nodes with cap=1, cost=0,
connect the extra nodes to i and n-i+1 (for all i) with cap=1, cost=-b[i] or 0 depending on whether the letter match with s[i] or not.
Finaly connect nodes 1 to n to the sink. Run MCMF would get the correct solution (print the the cost times -1).
https://vjudge.net/problem/CodeForces-884F

195. Evacuation (diff=2500, Dinic's algorithm)
It is obvious that this problem cannot be solved by greedy or dynamic programming, hence we try to construct a flow network. Let's firstly use BFS to compute the shortest distance from 'Z' to all cells. Then let's construct a level graph with t+2 levels. Connect
s to nodes in level 1 with capacity shown in the first grid. Connect level t + 2 nodes to t with capacity shown in the second grid.
Finally for nodes v1 in level i and v2 in level i+1, connect v1 to v2 iff v1 is adjacent to v2 and dist[v1] >= i and dist[v2] >= i.
Run maxflow would get the solution. The main lesson is for this type of very long problems, every sentence should be read carefully,
unless you want to get WA feedback. https://vjudge.net/problem/CodeForces-78E

196. Rectangle Painting 2 (diff=2500, Dinic's algorithm)
The key observation is we can do point compression on rows and columns seperately and partition the entire shape into several rectangle
regions. Then the problem is changed into the following, we can change all regions in some row/col with a given cost, what is the
minimum cost to change required cells black. This is a standard min-cut problem and can be solved by applying Dinic's algorithm.
https://vjudge.net/problem/CodeForces-1198E

197. Bipartite Segments (diff=2500, tarjan's algorithm, fenwick tree and line sweep)
The first observation is there's no nested cycle, so that after we use tarjan's biconnected component algorithm we can represent
each connected component as an interval [l, r], which l is the smallest vertex in that component and r is the largest index vertex
in that component. Then we establish 2 BITs to compute for each left end point i, what is the minimum r without a fully covered
interval. The problem is a quite standard line sweep problem and can be solved in O(nlogn) complexity. 
https://vjudge.net/problem/CodeForces-901C

198. Brackets (interval dp)
We define the sub problem(i, j) as the maximum matching by using brackets in the interval [i, j]. Then we can easily see that
we only need to consider where to partition the matching point. dp[i][j] = max(2match(i, j) + dp[i+1][j-1], dp[i][k] + dp[k+1][j], k=i..j-1) https://vjudge.net/problem/POJ-2955

199. Product Sum (diff=2500, convex-hull trick)
https://vjudge.net/problem/CodeForces-631E

200. Recursive Queries (diff=2500, line sweep and range tree lazy propagation)
The key observation is for each number its contribution is actually equal to qr - ql + 1, which qr refers to the right most position
such that the number is greater than all numbers between itself and qr, similar for ql. Hence, the problem is changed to a line 
sweep problem, we only need to calculate the total contribution of all numbers within the query range. We use range tree and lazy
propagation to solve this twice, once in the forward direction while another iteration in the backward direction.
https://vjudge.net/problem/CodeForces-1117G

201. Multiplication Puzzle (interval dp)
https://vjudge.net/problem/POJ-1651

202. B-number (digit dp)
https://vjudge.net/problem/HDU-3652

203. Bomb (digit dp)
https://vjudge.net/problem/HDU-3555

204. Blood Cousins (diff=2400, dfs and binary-lifting)
The obvious observation is this problem is equivalent to the following. Suppose that nv is the pth parent of v, we need to count
the number of nodes that is in the subtree of nv and has dist(nv, u)=p. For the find pth parent part, we can use binary lifting to do 
it. And for the counting part, we maintain a sorted vector for the dfs order of nodes of each level of the tree, and use binary search to find the left most and right most nodes that are in the same level of v and is in the subtree of nv. This solution works in
O(nlogn + mlogn) https://vjudge.net/problem/CodeForces-208E

205. Balanced Number (digit dp)
https://vjudge.net/problem/HDU-3709

206. AI robots (diff=2200, line sweep and dynamic range tree)
We use two pointers approach, pt1 points to the robot[i].x (in non-decreasing order), pt2 points to robot[i].x + robot[i].r (in
non-decreasing order). Then, before each time we query the total number of points between [robot[i].x - robot[i].r, x], we
delete all the points that its robot[j].x + robot[j].r cannot reach robot[i].x anymore. Using dynamic range tree is definitly
the best for this case, we simply maintain ~10^5 range trees, 1 for each IQ. https://vjudge.net/problem/CodeForces-1045G

207. Subtree Minimum Query (diff=2300, persistent range tree)
The solution is actually very simple, we establish persistent range trees according to the BFS order, and query the corresponding
tree according to the DFS order. https://vjudge.net/problem/CodeForces-893F

208. Mike and Feet (diff=2100, dp or binary search and sparse table)
The only thing I'm amazed with this problem is that I solved a standard dp problem with sparse table and binary search.
https://vjudge.net/problem/CodeForces-547B

209. The Bakery (diff=2200, dp, divide and conquer optimization)
The hardest part is how to calculate the cost(l, r), however, if we are familiar with Mo's algorithm i.e. always maintaing
the current valid window of cost, the problem is very easy to be solved in an amortized O(nklogn) complexity.
https://vjudge.net/problem/CodeForces-833B

210. Lucky Array (diff=2300, sqrt decomposition)
This problem has many solutions, we can either use sqrt decomposition or amortized range tree. https://vjudge.net/problem/CodeForces-121E

211. Quarrel (diff=2400, BFS)
The problem is actually very simple. let dist(i, j) refers to the shortest path to state i, j, then we use BFS to find the minimum
distance from state 1, n to state n, 1 without moving to any state (v, v) in the middle. https://vjudge.net/problem/CodeForces-29E

212. Salazar Slytherin's Locket (diff=2200, digit dp)
The observation is we only need to know how many times each digit occurs after the leading non-zero digit. We can use a bitmask
to represent the odd/even occurence of each digit 0-9. With memorization, we can easily get a complexity of O(q + 11*2^b*log(r)).
https://codeforces.com/problemset/problem/855/E

213. Two permutations (diff=2200, persistent range tree)
https://vjudge.net/problem/CodeForces-323C

214. Case of Fugitive (diff=2100, greedy and line sweep)
The problem can be solved by greedy should be figured out easily, however, how to do it correctly is not that stright forward.
We firstly sort all the gap according to a[i].r - a[i-1].l, and the bridges according to length. Then, we maintain a set of
bridges, which represents all the bridges that can be selected which length are no greater than a[i].r - a[i-1].l. Then, for
each gap we select the shortest bridge that is no less than a[i].l - a[i-1].r and remove the bridge from the set.
https://vjudge.net/problem/CodeForces-555B

215. DZY Loves Modification  (diff=2100, greedy)
Seperate rows and cols. https://vjudge.net/problem/CodeForces-446B

216. Pair of Numbers (diff=2100, math and binary search, sparse table)
The observation is actually very simple, we can validate if a[j] = gcd(l, r), and since as l decrease and r increase gcd(l, r) is
non-increasing, we can use binary search to get the optimal(l, r) for each j. Maintaining gcd(l, r) on a static array can be done
with sparse table. https://codeforces.com/problemset/problem/359/D

217. R2D2 and Droid Army (diff=2100, binary search and sparse table)
https://vjudge.net/problem/CodeForces-514D

218. Mishka and Interesting sum (diff=2100, line sweep and fenwick tree)
We process the queries offline, and always make sure for all numbers, we don't update its last occurrence in the BIT.
https://vjudge.net/problem/CodeForces-703D

219. Messenger Simulator (diff=2100, ordered statistic tree)
We introduce something called key, initially keys are equal to i. For each operation, we simply find the order of (key[v], v),
update max[v] and min[v] and then erase (key[v], v) from the ordered set. Finally, at the end of the operation, we add 
(minkey - 1, v) to the set. https://vjudge.net/problem/CodeForces-1288E

220. Same Sum Blocks (Hard) (diff=2200, data structures and greedy)
We can use prefix array to transform this porblem to a standard greedy problem. Select the maximum
amount of non-intersecting intervals from a group of intervals. https://vjudge.net/problem/CodeForces-1141F2

221. Clique Problem diff=2100, dp and data structures
The observation is, if we sort all the vertices according to x then if xj < xi and xi can connect to xj, then xi can connect
to all points in the clique which j has the largest x coordinate. Then, the rest of the problem is very simple after we rewrite the equation to xi - wi >= xj + wj. If we maintain a range max segment tree on xi+wi and process the points according to x increasing
order, then the problem is changed to a LIS problem, which can be solved easily in O(nlogn) time complexity.
https://vjudge.net/problem/CodeForces-527D

222. Tokitsukaze and Strange Rectangle  (diff=2200, line sweep and combinatory)
This problem is actually very hard. We need to know how to avoid double count for rectangles with the same y coordinate.
https://vjudge.net/problem/CodeForces-1190D

223. Multidimensional Queries (diff=2200, range tree and observation)
Since k <= 5, we can think how to solve this problem when k=1 or k=2. For k=1, we know that we can use divide and conquer range
tree to solve this problem, when we merge two intervals the answer is always lans, rans or lmax-rmin or rmax-lmin, we select
the maximum among those possible answers. Then, we might observe that for absolute values |a-b|, if we brute force all the cases
a > b or a <= b there are in total 1 << 5 cases which isn't too bad. And we also know the answer is the maximum among those
32 combinations. So the answer works as follows, we maintain range max, range min of (+-)b[l][1] (+-)b[l][2] (+-)b[l][3] .. (+-)b[l][k]
and use divide and conquer to merge them. Then final solution would work in O(160n + 32nlogn) which is fast enough.
https://vjudge.net/problem/CodeForces-1093G

224. Boredom (diff=2200, persistent range tree and combinatory)
https://vjudge.net/problem/CodeForces-853C

225. Arson In Berland Forest  (diff=2200, BFS and binary search on final answer)
There should be a health warning for this problem, it is absolutely a TLE giver.
https://vjudge.net/problem/CodeForces-1227E

226. Beard Graph (diff=2200, preparation for HLD)
https://vjudge.net/problem/CodeForces-165D

227. Drazil and Morning Exercise (diff=2800, persistent range tree, kruskal modification and tree dp)
We should immediately realize that q is only 50, which means that we can process the queries seperately. Firstly, let's do some 
precomputations, we preprocess the longest path (cost[i]) from every vertex i to a leaf using 2 dfs. Secondly, we use the kruskal modification algorithm, to produce a tree that satisfy for each node v every nodes u in its subtree has cost[u] >= cost[v].
Then the problem is changed to the following, we need to find the total number of nodes that's in the subtree of v which has cost
no greater than cost[v] + L. And we should realize that persistent range tree is perfect for this. 
https://codeforces.com/contest/516/problem/D

228. Round Subset (diff=2100, knapsack dp)
The observation is we can extract all the 2, 5 factor of a[1..n], then we define the subproblem as opt(i, j, k) be the maximum
number of factor 2 when select k numbers from the first i numbers with j fac 5. https://vjudge.net/problem/CodeForces-837D

229. Thwarting Demonstrations (diff=2200, fenwick tree and binary search for final answer)
This trick is too simple, just don't forget to push in 0 to the disc array when doing point compression. https://vjudge.net/problem/CodeForces-191E

230. A Heap of Heaps (diff=2200, persistent range tree and amortized complexity)
The problem is actually very easy to be solved. We note that only n/1 nodes in the first heap, n/2 nodes in the second heap and n/k valuable nodes in the kth heap which means that in total only O(nlogn) many nodes are useful query nodes. Hence, we can solve the 
problem with a smart brute force, for each valuable nodes we query the total number of nodes in a given range that has value less than
it. The query can be done in O(logn) if we use persistent range tree. Hence, the overall complexity is O(nlognlogn). 
https://vjudge.net/problem/CodeForces-538F

231. Duff in the Army (diff=2200, heavy-light decomposition)
We need to use heavy-light decomposition to decompose the tree in to ranges, and then we establish a range tree on sets to process
the queries. Overall complexity O(nlognlogn). https://vjudge.net/problem/CodeForces-587C

232. Smile House (diff=2300, binary lifting and matrices)
The problem is very nice. The first observation is we can binary search for the final answer, if the assumption that the smallest cycle
is less than v holds, any v' >= v would also holds. Hence, in order to compute v efficiently, we use the binary lifting trick. We
construct the shortest path matrices for 1-jump, 2-jump, 4 jump and so on. Then when we validate v, we can calculate matrix multiplication O(logv) many times. The total time complexity would be O(n^3lognlogn). https://vjudge.net/problem/CodeForces-147B

233. Getting Deals Done (diff=2300, greedy observation and binary search)
We should realize that the more task we solve, the more time we need. Hence, we can binary search for the final answer k and set d
to the kth smallest value of array p to validate each k. https://vjudge.net/problem/CodeForces-1070E

234. Company (diff=2300, range tree and LCA)
This is a tree observation problem. We can see that the LCA of a group of points in a tree is determined by the points with the minimum
and maximum dfsorder. Then the problem can be solved easily with the support of range min and range max range trees.
https://vjudge.net/problem/CodeForces-1062E

235. Happy Tree Party (diff=2300, heavy-light decomposition)
Almost HLD template problem, just be careful about the product overflow issue. https://vjudge.net/problem/CodeForces-593D

236. Cactus (diff=2400, tarjan's algorithm and heavy-light decomposition/LCA)
We could easily observe that for every simple cycle there are exactly 2 ways of getting from one point on the cycle to another point.
Hence, the problem is simply asking how many simple cycles are on the path from u to v. We can firstly use tarjan's algorithm
to extract all the biconnected components, and then for each query it is simply asking count the number of size > 1 components 
from u to v. It can be solved by LCA or heavy-light decomposition. https://vjudge.net/problem/CodeForces-231E


237. Construct a tree (diff=2300, binary search on final answer and graph construction)
We can binary search on the branching factor. Suppose we know that there exists an answer for branching_factor <= d, there must
exists an answer for branching_factor <= d + 1. After that we can greedily construct the tree (i.e. putting as mych nodes as
possible on the current level). https://vjudge.net/problem/CodeForces-1098C

238. Choosing Balls (diff=2200, observation and dp)
Only the top 2 colors are essential. https://vjudge.net/problem/CodeForces-264C

239. Anton and Permutation (diff=2300, sqrt decomposition)
We maintain O(sqrt(n)) many ordered vector for each sqrt range, and perform queries in O(qsqrt(n)logn) time and update in O(qsqrt(n))
time. https://vjudge.net/problem/CodeForces-785E

240. Voting (Hard Version) (diff=2300, greedy)
The observation is quite similar to "DZY Loves Modification". https://vjudge.net/problem/CodeForces-1251E2

241. Array and Segments (Hard version) (diff=2300, line sweep and range tree)
This is probably my worst performance problem of the month. Firstly, we can easily observe that we can iterate through all the i
to be the minimum of the resulting array, and apply all the updates that covers i completely. However, after that we should realize
the problem can be done efficiently by using line sweep, which I spent too long to do so.
https://vjudge.net/problem/CodeForces-1108E2

242. Printer (diff=2300, binary search on final answer and line sweep)
The problem is actually quite easy to come up with a O(n^2) solution. We know that only O(n) many priorities need to be checked.
A key observation is the lower the priority of task x, the later it would finish. Hence, we can binary search on the final answer!
After realizing this fact we search the minimum priority that satisfies the finishing time of task x is no later than T. The
problem would be reduced to a standard line sweep problem which can be solved with a priority queue.
https://vjudge.net/problem/CodeForces-253E

243. Marbles (diff=2200, bitmask dp and observation)
Let's firstly consider how to solve this problem by complete brute force. This is, we can brute force all the permutation of m (m=|{a[i]}|) and then assign each a[i] an element of the permutation, then we use divide and conquer algorithm to solve this problem. 
This approach works in O(m!n) which is too slow. Let's try to optimize the approach, we can firstly work out how many i occurs before j
for each pair of i, j and stores them in a 2-d array. Then, we let dp[state] represents the minimum number of inversion pairs to let all bits of state occupying the first bitcount(state) many chunks. Then the problem is a standard bitmask dp which can be done in
O(m^2*2^m + nm)

244. Three Pieces (diff=2200, dijkstra's algorithm/floyd-warshall algorithm)
Quite stright forward problem, just be careful with the level-graph construction. https://vjudge.net/problem/CodeForces-1065D

245. The Number Games (diff=2300, binary-lefting and amortized complexity)
Key observation if we can select number v (the largest remaining number), we should definitly take it, because of the property of
binary representations. Then, the problem is reduced to the following, we should query what's the total number of nodes on the path
from v to the nearest selected parent node and see if it is no greater than k, if so we brute force update all the nodes from v to
the parent node and decrease k. We should realize that the first type of operation can be done with binary-lifting because if a node
is updated all its ancestors should be updated as well. The second type of operation can be done with brute force in an amortized O(1)
complexity. Hence this solution works in O(nlogn). https://vjudge.net/problem/CodeForces-980E

246. Delete a Segment (diff=2300, line sweep)
My first observation was wrong. I tried to use union find to solve this problem. However, we should immediately realize that 
this is unfeasible because it is very hard to delete a range in union find data structure. Then I realized since we can only
delete 1 segment, after the deletion the number of connected component is going to increase at the point where this segment
is the only segment in that range [l, r] and there exists some segment [l',r'] and [l'',r''] such that l < r' and l'' < r.
We can use sweeping to figure out the increment value for each segment. One special case is, if the segment is disjoint to all
the other segment its removal cost should be -1. We should remove the segment with the largest removal cost and add that cost to
our initial answer. https://vjudge.net/problem/CodeForces-1285E

247. Blood Cousins Return (diff=2300, range tree and line sweep and binary-lifting)
We observe that the query corresponds to a concecutive BFS order interval. Hence, we can use binary search/binary lifting to figure
out the corresponding [l, r] bfs order of each query range in O(nlognlogn) time. Finally the problem is changed into the standard
line sweep and range tree problem, answer the number of distince elements in q [l, r] ranges which can be done in O(nlogn) time.
https://vjudge.net/problem/CodeForces-246E

248. Sum Queries? (diff=2300, obseration and range tree)
The key observation is something we might ignore, the optimal solution is definitly two smallest numbers with 1 digit all not equal to 0. After this is figured out, the problem would be a standard point update and range min query problem. https://codeforces.com/problemset/problem/1217/E

249. The Maximum Subtree (diff=2300, observation and tree dp)
If we draw enough examples, we can figure out the optimal solution is for each non-root node, it can attach 1 child with optimal structure and the remaining children. For the root is can attach 2 child with optimal structure and the remaining children. Since all nodes can be the root, we use 2 dfs to find the solution. https://vjudge.net/problem/CodeForces-1238F

250. Runner's Problem (diff=2300, line sweep and matrix)
For this kind of recursive formula, we can use matrix fast exponential algorithm to get the value of f(i, j) efficiently. For
the rest of the problem, we just need to know in the interval which matrix shall we use, which is a quite standard line sweep problem.
https://codeforces.com/contest/954/problem/F

251. Optimal Sum (diff=2300, line sweep and greedy)
The is a sliding window problem, we just need to maintain the k smallest negative numbers in a[i-len+1, i]. Make sure the invariant
of each function is clear. https://vjudge.net/problem/CodeForces-182C

252. Wormhouse diff=2300, backtracking and pruning
https://vjudge.net/problem/CodeForces-62D

253. Strip (diff=2300, sparse table and binary search and range tree, dp optimization)
https://vjudge.net/problem/CodeForces-487B

254. Buy Low Sell High (diff=2300, greedy observation)
We could observe the following fact about the stock trading. If we buy stock v1 and sell v3, it is equivalent to buy v1, sell v2, 
buy v2, sell v3. Hence, we can maintain a min heap and for every element if the heap is not empty, we check if the heap top is
less than the element, if so, we make a trasition and insert the element to the heap (this is very important because the element 
can still involve another trading). Otherwise, we insert the element to the heap.
https://vjudge.net/problem/CodeForces-865D

255. Sereja and Subsequences (diff=2300, dp and fenwick tree)
Let's define dp[i] as the number of valid subsequence that ends with number i. We can observe that dp[i] = i * (1 + sum(dp[j], j = 1..i-1) + delta) The hardest part is how to calculate this delta. Note that for a subsequence that ends with i, only subsequence ends with i and subsequence that ends with v < i can be the prefix of i. Hence delta should equal to the most recent version of dp[i].
Since we need to support point update and range sum query quickly, we can use a fenwick tree to speed up our dp procedure.
https://vjudge.net/problem/CodeForces-314C

256. Lomsat gelral (diff=2300, dsu on tree, merge from small to large)
The problem involves some very important technique. Let's solve the problem by a dfs traversal. For every node let's store
an unoredered_map<color, colorcnt>, a set<pair<colorcnt, color>> and ans and f (the node that actually representing this node).
Every time, when we are at a root node, we call merge(v, child[v]) for all u belongs to child[v]. What merge does is merge the smaller
unordered_map to the larger one and fix the f array. Initially we might think this is a O(n^2logn) approach. However, if we apply master theorem we can see the worst case of this approach is T(n) = kT(n/k) + O(nlogn) which is O(nlognlogn).
https://vjudge.net/problem/CodeForces-600E

257. Dominant Indices (diff=2300, dsu on tree, merge from small to large)
Almost the same as the previous problem. Just remember the map should be <depth, depthcnt> instead of <dist, distcnt>.
https://vjudge.net/problem/CodeForces-1009F

258. Tree Requests (diff=2400, binary search and bitmask)
If we solve this problem using a brute force way, we can achieve a time complexity of O(26 * mlogn). The approach is we establish
a level graph which stores the dfs order of nodes of each level for each letter. Then, when we process a query, we just use binary
search to find the L, R position of nodes on the level h which is in the subtree v. In order to make a string palindrome, there's
at most 1 letter occurs odd number of times, hence we can use the prefix sum array to maintain the occurence of letters. However, 
this approach would run only 20ms faster than the TL, any bad implementation would make it TLE. Since we only need to know the odd/
even occurence of letters a-z, instead of storing the occurence, we store the bitmask and use xor/countbits to maintain the queries.
This would wipe out the constant factor 26. https://vjudge.net/problem/CodeForces-570D

259. Mahmoud and a xor trip (diff=2200, tree dp and bit operation)
Let's represent value[v][i] as the cumulative xor sum of the ith bit from root to v. Then the ith bit of node v, u would contribute
to answer iff value[v][i] ^ value[u][i] ^ value[LCA(u, v)][i] ^ value[pre[LCA(u, v)]][i] = 1. Hence, we can use tree dp to solve this
problem, firstly count the number of 1 bit and 0 bit in the subtrees and use the above conditions to merge the results.
https://vjudge.net/problem/CodeForces-766E

260. Random Task (diff=2200, binary search and digit dp)
We can think what would happen if n is increased to n+1, we should consider how the bitcount change from [n+1, 2n] to [n+2, 2n+2].
We realize that n+1 has the same number of bits as 2n+2, hence the total number of bit k numbers is none decreasing if we increase n.
Therefore, we can binary search on the final answer and use digit dp to validate the solution.
https://vjudge.net/problem/CodeForces-431D


261. Igloo Skyscraper (diff=2400, range tree and CHT)
We know that convex-hull trick could deal with the dominate line at an x-coordinate query in O(logn) time and range tree could support
range queries. We should combine these two together. The solution works as follows, we sort the lines according to gradient and break the tie by the y-intersect. We maintain a range tree of CHT data structure and then insert the lines to all ranges that covers it (total O(logn)). When we query, we just call the query function of the CHT of the corresponding ranges. The solution works in O(nlognlogn). https://vjudge.net/problem/CodeForces-91E

262. Okabe and El Psy Kongroo (diff=2200, dp and matrix fast multiplication)
https://vjudge.net/problem/CodeForces-821E

263. TV Game (diff=2200, dp)
The only trick here is solve this problem backward. Instead of appending the numbers at the back, consider the string in a backward
direction and append the numbers to the front. https://vjudge.net/problem/CodeForces-31E

264. Skills (diff=2200, greedy and binary search)
The key observation is we can iterate on how many full-skill we are going to choose and if this number is equal to k, we should choose
the k largest skills. Then, we should use our remaining coins on maximizing the minimum skills which can be solved by using binary
search on final answer. https://vjudge.net/problem/CodeForces-613B

265. The Doctor Meets Vader (Medium) (diff=2300, Dinic's algorithm)
Firstly, I think this is a MCMF problem. But the time complexity might be too high. Note that there's only 2 costs. We can firstly
run Dinic's algorithm to find the largest bipartite matching of the graph. And then if we have the math observation, we should know
that the answer is either k times flow or h times b. (Lesson we learned, Dinic's algorithm is |V|^(5/2) on complete bipartite graph,
we shouldn't worry for |V| is up to 1000)
https://vjudge.net/problem/CodeForces-1184B2

266. Machine Programming (diff=2400, MCMF)
Learned a lot from this problem. It is obvious that the problem can be solved using MCMF. However, the graph construction isn't that
easy. We firstly get a unique vector of time (both s[i] and s[i] + t[i]) in sorted order. And connect the adjacent time with an edge
of cost 0, capacity k. This means that at any time there's at most k machine working. Then, we connect the vertex corresponds to
s[i] and s[i] + t[i] with an edge of capacity 1 and cost c[i]. After that we'll run MCMF and get the solution. 
https://codeforces.com/problemset/problem/164/C

267. Inna and Sequence (diff=2300, range tree and searching)
Delete a nonconsecutive segment is something that cannot be done with range trees. However, we might notice that there's only n operations. Which means that there's at most n numbers. We can establish a range tree and support delete the kth element, insert at
the back. When we deal with a deletion query we just delete a_i one by one, and this would achieved an amortized O(nlogn) complexity.
https://vjudge.net/problem/CodeForces-374D

268. Ann and Books (diff=2500, Mo's algorithm)
The problem simply asks to count the number of pairs such that the prefix sum differs by k. Counting the number of v in a range is 
usually undoable by range trees/fenwick trees. Hence, we use Mo's algorithm to solve the problem. We maintain a cnt hash map which
counts the number of occurence of each prefix, and the rest of the problem is routine Mo's insert and deletion. The overall complexity
of the solution is O(qsqrt(n)). https://codeforces.com/problemset/problem/877/F


269. Vasiliy's Multiset (diff=1800, Trie template)
This problem can test whether your trie template is correct.
https://vjudge.net/problem/CodeForces-706D

270. Kuro and GCD and XOR and SUM  (diff=2200, Trie and amortized complexity)
We should create 1e5 many tries. For a insertion query, we insert u to all tries with id | u. Then for the type-2 query, we just
need to search in the trie[ki] for the v that would produce the largest v ^ xi and xi + v <= si. Since n/1 + n/2 + ... + n/n = O(nlogn)
The overall complexity of the solution works in O(nlognlogn). https://vjudge.net/problem/CodeForces-979D

271. Anniversary (diff=2100, fibonacci property and math)
I actually know the key property of this problem. Fib(gcd(a, b)) = gcd(Fib(a), Fib(b)). But I got stuck on finding out
the maximum number that satisfy the property r/x - (l-1)/x >= k. The key observation here is the total amount of value n/i can have
is O(sqrt(n)), hence, we can iterate x=1..sqrt(r) and select the maximum r/i or i that satisfy the above equation.
https://codeforces.com/problemset/problem/226/C

272. Addition Robot (diff=2200, range tree and matrix)
Just be really careful on lazy propagation and range merge. Don't forget that matrix multiplication is not commutitive.
https://codeforces.com/problemset/problem/1252/K

273. Permutation Separation (diff=2200, range tree and line sweep)
Firstly, let's think how to solve this problem with a polynomial algorithm. We can immediately have an O(n^3) solution.
The solution works as follows, we brute force all the cost(i, j), which cost(i, j) means the splitting index is i,
which j is the maximum number in the left partition. Then, we might observe that we can sweep from 1-n and use a
range tree to maintain the cost when i is the maximum number in the left partition. 
https://vjudge.net/problem/CodeForces-1295E

274. Castle Defense (diff=2100, binary search and line sweep)
The problem seems routine after solving many other harder problems. 
https://vjudge.net/problem/CodeForces-954G

275. Tourist (diff=2400, DP and range tree optimization)
The problem might seems very hard. However, we must observe that position j can go to position i iff
|xi - xj| <= V * (ti - tj) which implies xi - V*ti <= xj - V * tj and xi + V*ti >= xj + V * tj.
Hence, the problem is reduced to a LIS problem. We can sort according to xi + V * ti then V * ti - xi.
Maintain a range tree on xi - V * ti. After than the problem is a routine range tree point update and
range max query problem. https://vjudge.net/problem/CodeForces-76F

* Mar 12 to Apr 11 --- "virus gap term training 2" focal point: dynamic programming, greedy and graph

276. Palindrome Degree (diff=2200, rolling hash)
https://vjudge.net/problem/CodeForces-7D

277. MUH and Cube Walls (diff=2000, KMP)
We firstly build a new array A(2e9)B. Which A[i] = b[i+1] - b[i], B[i] = a[i+1] - a[i]. Then just run the 
finding failure array function of the KMP algorithm and the number of nxt[i] = w-1 would be the final solution.
https://vjudge.net/problem/CodeForces-471D

278. Till I Collapse (diff=2600, persistent range tree and complexity analysis)
Let's think what would happen if we solve this problem using a smarter brute force. We let k iterate from 1 to n,
and solve the problem for each k. We firstly use a persistent range tree that would maintain the number of distinct
number from [l, r]. Then, for each k, we let i iterate from 1 to n, and i always jump to the leftmost point such
that query[i, inext] > k. The solution seems to work in O(n^2logn). However, we should note the following fact,
if query[i, inext] > k, inext - i >= k. Hence, for every k the number of calls to query function is at most n/k times.
Which means the overall complexity of the algorithm would work in logn(n + n/2 + n/3 + ...) = O(nlognlogn) which would
definitely run in TL. https://vjudge.net/problem/CodeForces-786C

279. 80-th Level Archeology (diff=2200, observation)
Since <= has trasitivity, the problem is equivalent to figure out the valid range that could make a[i] < a[i+1] and get the
intersection of these ranges. We can observe that for each i and i+1, there's at most 2 non-intersecting ranges that could make
a[i] < a[i+1]. Hence, we can use the prefix array to maintain this range addition operation. Note that Fenwick tree/range tree is
overkill here, since the query is after the update. https://vjudge.net/problem/CodeForces-731D

280. Ciel and Gondolas (diff=2600, dp and divide and conquer optimization)
https://codeforces.com/problemset/problem/321/E

281. Berland and the Shortest Paths (diff=2400, shortest path tree and backtracking)
The problem can be splited into 2 parts, firstly construct the shortest path dag using BFS, secondly
find combinations of the n-1 edges that can form a shortest path tree. The first part is quite standard.
The obstacle is how to do the second part correctly. We notice that except the root node, every node has
at least 1 parent, instead of doing the dfs from root to leaf and use backtracking, we can do the dfs from 2-n,
and use backtracking on the selected edges. https://vjudge.net/problem/CodeForces-1005F

282. Dish Shopping (diff=2800, line sweep and fenwick tree and ordered statistic tree)
This problem is doable, but I failed to solve it. The main obstacle is the sweeping order and the nested data structure.
https://vjudge.net/problem/CodeForces-1139F

283. Perfect Service (tree dp)
https://vjudge.net/problem/UVA-1218

284. DZY Loves Fibonacci Numbers (diff=2600, range tree, lazy propagation and fibonacci property)
We need to use F[n] = fib[n-1] * F[2] + F[1] * fib[n-2] and S[n] = F[n+2] - F[2] to solve this problem.
https://vjudge.net/problem/CodeForces-446C

285. Bipartite Checking (diff=2600, dynamic union-find, range tree on queries)
This is covered in Ray's assignment. https://vjudge.net/problem/CodeForces-813F

286. Mokia (CDQ divide and conquer)
https://vjudge.net/problem/HYSBZ-1176

287. Intersection of Permutations (diff=2300, CDQ divide and conquer)
The size of the intersection is equal to the number of points in the rectangle (x1,y1,x2,y2). If we express it more precisely,
it is (x1, y1, t, x2, y2, t). Which is a standard 3-dimensional partial order problem which can be solved by using CDQ divide and conquer.
https://vjudge.net/problem/CodeForces-1093E

288. Goodbye Souvenir (diff=2800, CDQ divide and conquer, line sweep observation)
Firstly let's think how to solve this problem if no update involved. We can use the standard line sweep technique.
We sort all the queries according to r, and do a line sweep, each time we update the previous occurence of the number.
We can use a fenwick tree to support this in O(nlogn) time. Now let's consider updates. It is like we do an update at time t,
and do a query at time t'. Hence another dimention involved, the problem is changed to a 3 dimensional partial order problem,
which can be done by using CDQ divide and conquer. https://vjudge.net/problem/CodeForces-848C

289. Heroes of Making Magic III (diff=2700, range tree and math observation)
The explaination is in the code. https://vjudge.net/problem/CodeForces-717F

290. Nearest Leaf (diff=2600, range tree and line sweep, dfs)
Initially I think this problem is undoable. Suddenly, I realized there's a reduced version of this problem which is much simpler.
Find the shortest distance from v (for every 1 to n) to any of the leaf. Which is a standard 2-time dfs problem. This problem
just add restrictions on the range of nodes that can be selected. Firstly, we preprocess the depth of the nodes and establish a
range tree of it (depth of non-leaf nodes are set to INF). Then, we do a second dfs, suppose nv is one of the child of v. We update
[1, nv-1] [nv+sz[nv], n] by weight(v, nv) and [nv, nv+sz[nv]-1] by -weight(v, nv). Every time we reach a node v, we answer all the 
range queries related to v. https://vjudge.net/problem/CodeForces-1110F

291. Building Forest (diff=2200, union find)
This problem is actually the template of CF813F. https://vjudge.net/problem/CodeForces-195E

292. Konrad and Company Evaluation (diff=2300, graph and complexity analysis)
The observation is the number of triple is equal to sum of out[i] * in[i] for all i from 1 to n.
https://vjudge.net/problem/CodeForces-1210D

293. Looksery Party (diff=2300, graph construction)
The most important sentence in the problem is every i would send a message to itself, think why. This would eliminate all -1 case!
https://vjudge.net/problem/CodeForces-549B

294. Leha and another game about graph (diff=2100, graph construction)
We could shown that the graph has solution is equivalent to its spanning tree has solution.
https://codeforces.com/contest/841/problem/D

295. Chemistry in Berland (diff=2400, dfs)
The only difficulty about this problem is the number might overflow, but we should realize if the required amount is less than 1e17,
then it is impossible to make the chemical reaction happen. https://vjudge.net/problem/CodeForces-846E

296. One-Way Reform (diff=2300, Hierholzer's algorithm, Euler tour, observation)
The very important observation is if the graph consists an Euler tour all nodes can satisfy the in=out condition.
https://vjudge.net/problem/CodeForces-723E

297. Array and Operations (diff=2400, Dinic's algorithm)
It can be seen easily that this is a matching problem. We split according to odd and even indices and for each number we do prime
factorization and connect the common prime for each good pairs with INF capacity. https://vjudge.net/problem/CodeForces-498C

298. President and Roads (diff=2600, dijkstra's algorithm and tarjan's bridge finding algorithm)
The solution is very simple, we run dijkstra's algorithm twice and see if an edge is on the shortest path. Then, we construct 
the shortest path (undirected) dag and find the bridges in that dag. Finally, when we do classification of edges, we return "YES",
only if the edge is on the shortest path dag and is a bridge. Be really careful about the parrallel edges case.
https://vjudge.net/problem/CodeForces-567E

299. Graph Coloring (diff=2300, dfs)
We should analyse how to make all edges red. It is for each red edge we either switch both of its endpoints or none and for each blue
edge we switch one of its endpoint. This would reduce the problem to a dfs coloring problem and can be solved in O(n+m) time.
https://vjudge.net/problem/CodeForces-662B

300. Cactusophobia (diff=2300, Dinic's algorithm and tarjan vertex biconnected component)
I would review this problem once in a while, because it is so nice. https://codeforces.com/contest/720/problem/B

301. Underfail (diff=2400, MCMF)
The problem is very similar to problem164C machine programming the graph construction procedure is almost the same.
https://codeforces.com/problemset/problem/717/G

302. Deciphering (diff=2400, MCMF)
The can calaulate how many match(a, b) (i.e. a in the first string match b in the second string), match(a, c)... match(Y, Z) for all k*k pairs.
Then the problem would be turned into a MCMF problem and can be solved easily. https://vjudge.net/problem/CodeForces-491C

303. Privatization of Roads in Berland (diff=2600, Dinic's algorithm)
The explaination is in my code. Learned something from Ray. https://vjudge.net/problem/CodeForces-1070I

304. Road Construction (diff=2600, Dinic's algorithm and tarjan's bridge finding algorithm)
Since the graph is a functional graph, we can only remove at most 1 cycle edge. Hence, we can firstly run the tarjan's bridge finding
algorithm and then the problem would be turned into a matching problem. https://vjudge.net/problem/CodeForces-1252L

305.  Electric Scheme (diff=2600, Dinic's algorithm and data structures, observation)
We can think this problem as merge horizontal/vertical intervals together without producing any extra intersection points. Then we could
transform the problem into a project selection type min-cut problem. We create a bipartite graph, put all horizontal segments on the left,
vertical segments on the right. Then, for every edge we cut means we force to abandon that merge. For each invalid intersection of horizontal
and vertical segments we connect an edge with INF capacity. Then the final answer would be the complement of the segments in the min-cut.
To make our life easier, we can use some data structures to solve this. https://codeforces.com/problemset/problem/1054/F

306. Gang Up (diff=2600, MCMF)
The technique to construct x^2 cost is similar to a 2300-MCMF problem. It is connect x edges which are 1,3,5,7,... And the technique to model
graph traversal is similar to problem 78E, which is construct a 100-level graph. Combining those 2 techniques would give a MCMF solution.
https://vjudge.net/problem/CodeForces-1187G

307. Black and White Tree (diff=2200, graph construction)
The key observation here is for the edge connects a leaf node and its parent, the edge must have a weight equal
to the leaf node weight. Hence, we can create this tree greedily in a bottom up approach.
https://vjudge.net/problem/CodeForces-260D

308. Privatization of Roads in Treeland (diff=2500, graph construction)
Solve this problem greedily. https://vjudge.net/problem/CodeForces-1141G

309. Road Problem (diff=2600, tarjan's biconnected component, construction)
This problem is equivalent to add the minimum amount of edges to make the graph into one biconnected component. The approach is very
simple, firstly find all the biconnected components and compress the points to make the graph into a tree. Then, we should connect
the leaves pairwise (the order is very important, according to dfs order 1->ans/2, 2->ans/2+1 etc.).
https://vjudge.net/problem/CodeForces-45H

310. Make k Equal (diff=2400, observation)
First observation, the final element should be an element in the array. Hence, we can sort and calculate the cost of making at least k
elements equal to a[i]. https://codeforces.com/problemset/problem/1328/F

311. Cheap Robot (diff=2600, kruskal modification and dijkstra, observation)
The first observation I had when solving this problem is if we define w(i, j) as the shortest distance between i and j, then by the
property of Kruskal minimum spanning tree, the kruskal tree formed by the k special nodes with w(i, j) as edge weight is the tree
that would describe the answer. When we query i, j we simply return the node value of LCA(i, j). However, how can we build the kruskal
tree efficiently. The key observation here is we can replace our initial edge weight with dist[i] + w + dist[j], where dist[i] is the
shortest distance of the ith node to any of the k special nodes. Then, we can just build the kruskal tree based on the new weights.
The reason for this to work is because if we want to go accross an edge, we have to be safe to move like special_node ->... u->v->special_node.
Then if two special node has shortest distance greater than dist[i] + w + dist[j], this edge cannot be used. 
https://vjudge.net/problem/CodeForces-1253F

312. Vladik and Entertaining Flags (diff=2600, union find, range tree and divide and conquer)
Since this is a range query problem, we should directly think the use of range trees. We should consider what would happen if we merge
2 connected connected components together. Only the cells on the boarder can affect the result.
https://vjudge.net/problem/CodeForces-811E

313. Matching vs Independent Set (diff=2200, observation)
The observation is we can greedily select the matching, if there's no n matching in the graph, then the remaining
vertices must form an independent set. Think why :). https://vjudge.net/problem/CodeForces-1198C

314. Trails and Glades (diff=2400, construction)
This is definitely not a hard problem, but it is something we might get wrong. The main WA point is 1 might be an isolation vertex.
https://codeforces.com/problemset/problem/209/C

