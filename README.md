# codeforce practice
codeforce practice summary update everyday

* Aug 30 to Sep8:


1. Rooks and Rectangles (div1, diff=2400, segmenttree and line sweep)
http://codeforces.com/problemset/problem/524/E

2. Cannon (div2, diff=2100, two pointers)
http://codeforces.com/problemset/problem/47/E

3. Buses and People (div2, diff=2400, segmenttree and line sweep)
https://codeforces.com/contest/160/problem/E

4. Summer Homework (diff=2500, segmenttree and math)
http://codeforces.com/problemset/problem/316/E3

5. Sum of Medians (diff=2200, segmenttree and divide and conquer)
https://codeforces.com/problemset/problem/85/D

6. Fire (div2, diff=2000, dynamic programming)
http://codeforces.com/problemset/problem/864/E

7. Package Delivery (div1/2, diff=2300, greedy)
https://codeforces.com/problemset/problem/627/C

8. Let Them Slide (div1/2, diff=2200, segmenttree and lazypropagation)
http://codeforces.com/problemset/problem/1208/E

9. Stripe 2 (codeforces round #21, diff=2300, dynamic programming)
http://codeforces.com/problemset/problem/21/C

10. Bulmart (2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest, diff=2200, greedy and binary search)
http://codeforces.com/problemset/problem/730/C

11. Preparing for the Contest (div1, diff=2100, greedy and binary search)
http://codeforces.com/problemset/problem/377/B

12. GukiZ hates Boxes (div2, diff=2200, greedy and binary search)
https://codeforces.com/problemset/problem/551/C

13. Stressful Training (div2, diff=2300, greedy and binary search)
http://codeforces.com/problemset/problem/1132/D

14. On Changing Tree (div1, diff=2400, segmenttree and dfs)
http://codeforces.com/contest/396/problem/C

* Sep 9 to Sep 16:


15. Frogs and mosquitoes (div2, diff=2500, segmenttree, greedy and set)
http://codeforces.com/contest/609/problem/F

16. Noise Level (div2, diff=2000, graph, bfs)
http://codeforces.com/contest/847/problem/I

17. Reachability from the Capital (div3, diff=1900, strongly connected component)
http://codeforces.com/contest/999/problem/E

18. Checkposts (div2, diff=1700, strongly connected component)
https://codeforces.com/contest/427/problem/C

19. Inna and Binary Logic (div2, diff=2400, segment tree and divide and conquer)
https://codeforces.com/contest/400/problem/E

20. Online Courses In BSU (VK Cup 2017 - Qualification 2, diff=1900, topological sort)
https://codeforces.com/contest/770/problem/C

21. The Child and Sequence (div2, diff=2300, segment tree and math)
https://codeforces.com/contest/438/problem/D

22. Closest Equals (VK Cup 2015 - Qualification Round 1, diff=2200, segment tree and sliding windows)
https://codeforces.com/contest/522/problem/D

23. One Occurrence (div2, diff=2400, segment tree and two pointers)
https://codeforces.com/problemset/problem/1000/F

24. Vasya and a Tree (div2, diff=1900, dfs definition and offline segment tree)
https://codeforces.com/problemset/problem/1076/E

25. Little Elephant and Tree (div1, diff=2400, dfs and offline segment tree)
https://codeforces.com/problemset/problem/258/E

26. Water Tree (div1, diff=2100, dfs and segment tree)
https://codeforces.com/contest/343/problem/D


* Sep 17 to Sep 23:

27. Buy a Ticket (div2, diff=2000, graph modification and dijkstra)
https://codeforces.com/contest/938/problem/D

28. 0-1-Tree (div2, diff=2300, tree DP) this problem needs more working on it!
https://codeforces.com/contest/1156/problem/D

29. Please, another Queries on Array? (div2, diff=2500, segment tree, bitset and math)
https://codeforces.com/problemset/problem/1114/F

30. Misha, Grisha and Underground (div2, diff=1900, math and lca using rmq)
https://codeforces.com/contest/832/problem/D

31. Kilani and the Game (div2, diff=1900, bfs) 
https://codeforces.com/problemset/problem/1105/D

32. Bertown roads (div2, diff=2100, tarjan's bridge finding algorithm)
https://codeforces.com/problemset/problem/118/E

* Sep 24 to Sep 30:

33. Scheme (div2, diff=2400, tarjan's scc and point compression)
https://codeforces.com/contest/22/problem/E

34. Roads not only in Berland (div2, diff=1900, Kruskal MST)
https://codeforces.com/problemset/problem/25/D

* Oct 1 to Oct 7:

35. Legency (div1, diff=2600, segment tree and dijkstra)
https://codeforces.com/problemset/problem/786/B

36. Paths and Trees (div2, diff=2100, dijkstra)
https://codeforces.com/problemset/problem/545/E

37. st- spanning tree (div2, diff=2200, kruskal and greedy)
https://codeforces.com/problemset/problem/723/F

38. Queue (Codeforces Beta Round, diff=2300, AVL tree)
https://codeforces.com/contest/38/problem/G

* Oct 8 to Oct 13:

39. The Shortest Statement (div2, diff=2300, dijkstra and LCA) 
https://codeforces.com/problemset/problem/1051/F

40. Strictly Positive Matrix (div2, diff=2200, tarjan scc and math)
https://codeforces.com/problemset/problem/402/E

41. Analysis of Pathes in Functional Graph (div2, diff=2100, binary lifting) 
https://codeforces.com/problemset/problem/702/E

42. We Need More Bosses (div2, diff=2100, tarjan and tree dp)
https://codeforces.com/problemset/problem/1000/E

* Oct 14 to Oct 20:

43. Beautiful numbers (div2, diff=2400, dight dp)
https://codeforces.com/problemset/problem/55/D

44. Magic Numbers (div2, diff=2200, digit dp)
https://codeforces.com/problemset/problem/628/D

45. Roman and Numbers (div2, diff=2000, digit dp and bitmask)
https://codeforces.com/problemset/problem/401/D

46. Segment Sum (div2, diff=2300, digit dp and bitmask)
https://codeforces.com/problemset/problem/1073/E

* Oct 21 to Oct 27:

47. Ilya and Roads (div2, diff=2100, DP and greedy)
https://codeforces.com/problemset/problem/313/D

48. Lunar New Year and Red Envelopes (div2, diff=2100, DP and line sweep)
https://codeforces.com/problemset/problem/1106/E

49. Sequence (Codeforces Beta Round #13, diff=2200, DP)
https://codeforces.com/contest/13/problem/C

50. Bad Luck Island (div2, diff=2100, DP and probability)
https://codeforces.com/contest/540/problem/D

51. Linear Kingdom Race (div1, diff=2400, DP and segment tree and line sweep)
https://codeforces.com/contest/115/problem/E

52. Trains and Statistic (div2, diff=2500, DP and segment tree and greedy) 
https://codeforces.com/contest/675/problem/E

53. Bear and Tree Jumps (VK Cup 2017 - Round 1, diff=2100, tree DP)
https://codeforces.com/problemset/problem/771/C

* OCt 28 to Nov 3:

54. Coloring Brackets (div2, diff=2200, interval DP) 
https://codeforces.com/contest/149/problem/D

55. Periodic RMQ Problem (Educational Codeforces Round 20, diff=2500, segment tree and point compression)
https://codeforces.com/contest/803/problem/G

* Nov 17 to Nov 24:

56. Cow (Poj2481, line sweep and fenwick tree)
https://vjudge.net/problem/POJ-2481

57. Stars in Your Window (Poj2482, line sweep and segment tree lazy propagation)
https://vjudge.net/problem/POJ-2482

58. Camping Groups (Croc Champ 2012 - Round 1, line sweep & fenwick tree & segment tree, diff=2600)
https://codeforces.com/contest/173/problem/E

* Nov 25 to Dec 11:

59. A and B and Lecture Rooms (div2, diff=2300, LCA and dfs)
https://codeforces.com/contest/519/problem/E

60. Road Improvement (div1, diff=2300, dp // worst problem I've ever seen)
https://codeforces.com/problemset/problem/543/D

61. Little Elephant and Inversions (div1, diff=2400, fenwick tree and line sweep) 
https://codeforces.com/contest/220/problem/E

62. Yaroslav and Divisors (div1, diff=2200, fenwick tree and line sweep) 
https://codeforces.com/contest/301/problem/D

63. Bear and Bowling 4 (Educational Codeforces Round 11, diff=2500, convex-hull and dp)
https://codeforces.com/contest/660/problem/F

64. Tree (div1 + div2, diff=2200, binary-lifting and dp) 
https://codeforces.com/contest/932/problem/D

65. Send the Fool Further! (medium) (Helvetic Coding Contest 2017, diff=2100, tree dp) 
https://codeforces.com/contest/802/problem/K

66. Tree with Maximum Cost (div3, diff=2100, tree dp)
https://codeforces.com/contest/1092/problem/F

* Dec 12 to Feb 11 summer holiday training --- data structure + graph + string  

67. Dog Food (div2, diff=2300, greedy)
https://codeforces.com/contest/847/problem/D

68. Berland University (diff=2100, greedy and binary search)
https://codeforces.com/contest/1090/problem/L

69. Complete The Graph (diff=2200, dijkstra)
https://codeforces.com/problemset/problem/715/B

70. Three States (diff=2200, dijkstra)
https://codeforces.com/problemset/problem/590/C

71. Case of Chocolate (diff=2500, range tree)
https://codeforces.com/problemset/problem/555/C

72. REQ (diff=2500, range tree and sweeping and number theory)
https://codeforces.com/problemset/problem/594/D

73. Wires (diff=2200, graph and dfs)
https://codeforces.com/problemset/problem/1250/N

74. Petya and Graph (diff=2400, Dinic's algorithm and maximum enclosure graph)
https://codeforces.com/problemset/problem/1082/G

75. Jeff and Removing Periods (diff=2700, fenwick tree, line sweep)
https://codeforces.com/contest/351/problem/D

76. Soldier and Traveling (diff=2300, Dinic's algorithm and extracting flow)
https://codeforces.com/contest/546/problem/E

77. Exploration plan (diff=2400, Dinic's algorithm and Floyd algorithm and binary search for final answer)
https://codeforces.com/problemset/problem/852/D

78. Valera and Queries (diff=2400, fenwick tree, line sweep)
https://codeforces.com/problemset/problem/369/E

79. Minimal Labels (diff=2400, greedy and topological sort)
https://codeforces.com/problemset/problem/825/E

80. Diverging Directions (diff=2100, LCA and range tree and dfs)
https://codeforces.com/problemset/problem/838/B

81. Flipping Frustration (extended euclidian algorithm)
https://vjudge.net/problem/UVA-11312

82. Airport Express (dijkstra, path construction)
https://vjudge.net/problem/UVA-11374

83. Drivers Dissatisfaction (diff=2500, Kruskal, greedy, LCA)
https://codeforces.com/contest/733/problem/F

84. Tourist Reform (diff=2400, tarjan's algorithm, bridge finding and biconnected component)
https://codeforces.com/contest/732/problem/F

85. Robots in a DAG (codechef, Dinic's algorithm, construct flow graph in stages)
https://www.codechef.com/problems/ROBOTDAG

86. The K-League (uva, Dinic's algorithm, allocation problem)
https://vjudge.net/problem/UVA-1306

87. Gripping Story (diff=2400, range tree, amortized complexity and searching)
https://codeforces.com/problemset/problem/198/E

88. Radio stations (diff=2400, line sweep and dynamic range tree)
https://codeforces.com/problemset/problem/762/E

89. Developing Game (diff=2400, line sweep and range tree, solved after reading solutions, problem reduction part is stunning)
https://codeforces.com/contest/377/problem/D

90. Army Creation (diff=2300, persistent range tree)
https://codeforces.com/problemset/problem/813/E

91. Board Game (diff=2400, range tree searching, BFS) 
https://codeforces.com/problemset/problem/605/D

92. DQUERY (spoj, Mo's algorithm (range tree/fenwick tree definitly works but Mo's algorithm is excited))
https://vjudge.net/problem/SPOJ-DQUERY

93. Tree and Queries (diff=2400, Mo's algorithm)
https://codeforces.com/contest/375/problem/D

94. Tempter of the Bone (hdu, dfs and backtracking and pruning)
https://vjudge.net/problem/HDU-1010

95. Hot is Cold (diff=2400, range tree and 2-tag lazy propagation, exactly the same technique as codeforce817f MEX query)
https://codeforces.com/problemset/problem/1146/E

96. K-th Number (poj, persistent range tree, searching)
https://vjudge.net/problem/POJ-2104

97. George and Cards (diff=2500, sparse table and fenwick tree and binary search)
https://codeforces.com/contest/387/problem/E

98. Destiny (diff=2400, persistent range tree finding kth largest number and observation)
https://codeforces.com/problemset/problem/840/D

99. Startup Funding (diff=2400, binary search and sparse table and probability)
https://codeforces.com/problemset/problem/633/E

100. Traffic Jams in the Land (diff=2400, range tree, divide and conquer, math observation)
https://codeforces.com/contest/498/problem/D

101. Fire in the City (diff=2500, line sweep and binary search for final answer)
https://codeforces.com/contest/845/problem/E

102. Yet Another Multiple Problem (2012 chengdu regional contest, BFS on numbers)
https://vjudge.net/problem/UVA-1653

103. Angry Programmer (uva, a very simple max flow problem on vertex capacity)
https://vjudge.net/problem/UVA-11506

104. Sorting It All Out (poj, uniqueness of top-sort)
https://vjudge.net/problem/POJ-1094

105. A Famous Grid (spoj, SIEVE and BFS, create a larger grid to deal with the walk out case!)
https://vjudge.net/problem/SPOJ-SPIRALGR

106. Mushroom Gnomes - 2 (diff=2500, range tree and probability)
https://codeforces.com/contest/138/problem/C

107. Following Orders (uva, top-sort BFS approach with backtracking, extracting all top-sort order in dictionary order, good template)
https://vjudge.net/problem/UVA-124

108. Nastya and King-Shamans (diff=2600, range tree and pruning, learned a valuable lesson in time complexity analysis)
https://codeforces.com/contest/992/problem/E

109. Functions on the segments (diff=2600, persistent range tree, solved after getting feedback for 9 times! Note that if only single point value is required we don't need lazy tag!)
https://codeforces.com/contest/837/problem/G

110. Hanger (diff=2300, set and fenwick tree)
https://codeforces.com/problemset/problem/74/D

111. Trip to Saint Petersburg (diff=2300, line sweep and range tree and lazy porpagation, this problem is similar to 115E linear kingdom race)
https://codeforces.com/problemset/problem/1250/C

112. Choose a Square (diff=2500, line sweep and range tree and lazy propagation, another problem similar to 115E linear kingdom race)
https://codeforces.com/contest/1221/problem/F

113. Parking Lot (diff=2500, set and implementation)
https://codeforces.com/problemset/problem/219/E

114. The doors (uva, simple geometry and bellman-ford algorithm, remember the special case for judging two intervals intersection)
https://vjudge.net/problem/UVA-393

115. Queue in the Train (diff=2300, line sweep and priority queue optimization, how to order the event is very important)
https://codeforces.com/contest/1239/problem/C

116. Heidi and the Turing Test (Medium) (diff=2300, line sweep and range tree, change the coordinate system)
https://codeforces.com/problemset/problem/1184/C2

117. Performance Review (diff=2300, range tree and lazy propagation, key observation: the value itself is useless, only >, < matters)
https://codeforces.com/contest/1252/problem/G

118. King Kog's Reception (diff=2400, range tree and divide and conquer)
https://codeforces.com/contest/1089/problem/K

119. Cave Raider (bellman-ford algorithm, shortest path with constraints on path entry time)
https://vjudge.net/problem/POJ-1613

120. Segment Tree (diff=2100, graph connectivity, union find, range tree, complexity analysis, sweeping)
https://codeforces.com/contest/1278/problem/D

121. Find a Number (diff=2200, BFS on remainder, same trick as "Yet Another Multiple Problem")
https://codeforces.com/problemset/problem/1070/A

122. More Queries to Array... (diff=2600, range tree and lazy propagation and binomial theorem)
https://codeforces.com/problemset/problem/266/E

123. Connected Components? (diff=2100, dfs and union-find and range tree to create the graph)
https://codeforces.com/contest/920/problem/E

124.  Bear and Forgotten Tree 2 (diff=2400, dfs and union-find and range tree graph creation, similar to the previous one just with more observation) 
https://codeforces.com/contest/653/problem/E

125. Shortest Path (diff=2100, shortest path, some trick when doing relaxation)
https://codeforces.com/contest/59/problem/E

126. Greedy Elevator (diff=2500, fenwick tree and set, good implementation problem)
https://codeforces.com/contest/257/problem/E

127. Intervals (uva, system of different constraints)
https://vjudge.net/problem/UVA-1723

128. Sereja and Straight Lines (diff=2400, binary search for final answer and line sweep, similar to 845E and 1184C2)
https://codeforces.com/contest/314/problem/D

129. King (central Euro 1997, system of different constraints)
https://vjudge.net/problem/POJ-1364

130. XOR and Favorite Number (diff=2300, Mo's algorithm, need to be very clear on what [l, r] means when maintaining prefix sum)
https://codeforces.com/contest/617/problem/E

131. Cutting a Fence (diff=2400, probability and range tree and lazy propagation on arithmetic progression)
https://codeforces.com/contest/212/problem/D

132. Little Elephant and Shifts (diff=2300, map and math observation)
https://codeforces.com/problemset/problem/220/C

133. Powerful Array (diff=2700, Mo's algorithm)
https://codeforces.com/contest/86/problem/D

134. Serega and Fun (diff=2600, sqrt decomposition, I'm not familiar with deque STL access method which caused me getting WA feedback for 4 times)
https://codeforces.com/contest/455/problem/D

135. Music in Car (diff=2500, line sweep and sets, I think this problem requires some implementation techniques, for example creating
two structs instead of using functions to handle the time addition event would make our life a lot easier)
https://codeforces.com/contest/746/problem/F

136. Play on Words (central Europe, union find and Euler path existence checking, I think the most important observation is using words as "edges" of the graph) https://vjudge.net/problem/UVA-10129

137. Cardboard Box (diff=2500, greedy and fenwick tree, I was killed by this problem :( )
This problem requires the following greedy observation, suppose that an optimal solution has the maximum b[k] at index k, then
we could proof that all [1:k] have been selected at least for level 1. Then the problem is quite routine, using fenwick tree and
binary search would easily give a solution of O(n*logn*logn).
https://codeforces.com/contest/436/problem/E

138. Catenyms (least alphabetical ordered Euler path and Hierholzer's algorithm)
https://vjudge.net/problem/UVA-10441

139. Bear and Contribution (diff=2500, greedy and priority queue)
I wasted valuable time because of ignoring the fact that the final T can be a number not in the given array.
This problem has a very trivial greedy observation which is we need to select k numbers that has the minimum cost to increase
them to T. However, we need to be aware how to maintain a window of k numbers with minimum cost, using priority queue here is
definitly the best choice. https://codeforces.com/contest/639/problem/D

140. Working routine (diff=2600, linked list)
This problem requires some implementation technique, firstly since n = 1000, m = 1000 and q = 10000, we know that O((m+n)q) is
good enough to pass the tests. Note that swapping two submatrix only require to change the connection links. Hence, linked-list
is the best data structure for this type of query. https://codeforces.com/contest/706/problem/E

141. Donkey and Stars (diff=2600, line sweep and geometry and range tree)
This problem taught me some valuable lessons even if I solved it without the support of any solutions. 1. when we are solving
geometry problems, use "/" as few as possible to eliminate TLE. 2. pair<int, index (int)> would be more efficient than pair<int, object> when making a pair. Beyond that, this problem is still very nice. We firstly changed the problem to a LIS problem by math observation,
and after that since the > is defined by two conditions, we can use the standard trick of range tree and line sweep to solve it.
https://codeforces.com/contest/249/problem/D

142. Trips (diff=2100, graph connectivity, working backward and sets)
This graph problem is very interesting. The key observation is when i increases from 1 to m, the tourist set size can only increase.
Hence, we can work backward, firstly add in all the edges. Then, we delete all the edges one by one and always see whether there's an
element with degree less than k, if so eliminate the element. https://codeforces.com/problemset/problem/1037/E

143. Bribes (diff=2300, dfs and LCA and prefix sum)
I got WA for 3 times because of solving a different problem! There's an obvious observation that we only need to know how many times
each road is used. Hence, we use the prefix sum technique that was used in on changing tree.

144. World Tour (diff=2100, BFS and path construction)
This problem has the following observation. If you fix the 2nd and 3rd point, we only need to find the valid 1st and 4th point,
with maximum dist(1, 2) + dist(3, 4) + dist(2, 3). Hence, we can run a BFS to find the pair-wise shortest path, then we might realize
that maximum dist(1, 2) and dist(3, 4) might contain duplicate points (e.g. pt(1) == pt(3)) which is invalid, we need to record
3 points i with maximum distance dist(i, v) / dist(v, i) for each v. https://codeforces.com/contest/666/problem/B

145. Ratings and Reality Shows (diff=2500, range tree and divide and conquer)
I got WA for 4 times and fixed the code for 1.5 hours because of a long long :( . This problem could be solved by using range tree
and divide and conquer. The observation is we only need to make sure the following two values are not less than 0: 1) start +
min_prefix up to t 2) start + prefix up to t + range min sum start from t end at t + len - 1. 
https://codeforces.com/contest/887/problem/D

146. Polycarp and Hay (diff=2100, union-find and dfs)
The observation is since there is a number that must be fixed, we can sort the numbers in the grid which are factors of k in decreasing
order, then the problem is reduced to determine whether there exists a connected component which contains no less than k / g[i][j] numbers, then a union-find and dfs would simply do the job. https://codeforces.com/contest/659/problem/F

147. MST Unification (diff=2300, Kruskal and LCA, binary lifting)
The trick Ray covered in the problem set on MST is very useful. I've already solved more than 3 problems using this trick.
https://codeforces.com/contest/1108/problem/F

148. Optimal Milking (binary search for final answer, Dinic's algorithm)
This problem is similar to codeforce852d, we firstly preprocess all the pair-wise shortest path using Floyd algorithm. Then we binary
search the final answer and use Dinic's algorithm to validate. https://vjudge.net/problem/POJ-2112

149. Panic Room (min-cut)
This problem is very easy. It just asks whether some vertices can all be seperated from a given sink. Add a super source and connects
to all the vertices need to be seperated with INF, connect the forward edges with capacity 1 and backward edges with capacity INF. Then
just run Dinic's algorithm would find the solution. https://vjudge.net/problem/UVALive-3632

150. Cup Trick (diff=2500, balanced tree)
The observation for this problem is there are two cases the task cannot be fulfilled. 1) when you try to move the kth position cup i
to the front, there's a cup j != i at position k. 2) the ith cup is at some other location. Hence, we need to design a data structure
that supports the following 1) insert an element 2) delete an element 3) find the kth smallest element. Any type of balanced tree would
work. However, ordered statistic tree is very slow :(, I wrote an AVL tree and used some fast io techniques to pass the tests.
https://codeforces.com/contest/420/problem/D

151. Kaka's Matrix Travels (MCMF)
This problem verifies the correctness of the MCMF template. Since all points can be walked trough k times, with 1 time that can achieve 
the profit, we set each vertex with a vertex capacity of 1 and vertex cost of v. Then run the MCMF algorithm would find the solution.
https://vjudge.net/problem/POJ-3422

152. Going Home (MCMF)
https://vjudge.net/problem/UVALive-3198

153. Build String (diff=2100, MCMF)
This problem is quite easy. Just add nodes to represent sentences and connect the source to it with cap=a[i] and cost=0,
add the sentence to the a-z nodes with the word count and cost=i, then add the a-z nodes to the target with cost=0, cap=target_cnt.
https://codeforces.com/contest/237/problem/E

154. Binary Tree on Plane (diff=2400, MCMF)
This is the kind of problem we think it is impossible to be done without flow. If we think this might be a flow problem, we have 
the following observation. For a binary tree, each node has at most 2 outlink and at most 1 in link. And for n points if it is a
tree, it must have n-1 points with 1 in link. Hence, we can create the flow graph as follows, add edges with cap 2 and cost 0,
from the super source to all the in vertices, add edges with cap 1 and cost equals to the Euclidian distance from the in vertices
to the out vertices that below them, finally add edges with cap 1 and cost 0 from the out vertices to the super sink. Run MCMF would
give the correct solution. https://codeforces.com/problemset/problem/277/E

155. Olympiad in Programming and Sports (diff=2200, MCMF)
I don't know how to solve this problem using an O(n^2) dp, hence, I'm using MCMF to solve it. The flow establish process looks as
follows. Add a super source connects to all 1-n person with cap 1 cost 0, add all 1-n person to the node n+1 with cap 1 cost a[i],
similarly to n+2 with cap 1 cost b[i]. Finally connects n+1 to super sink with cap p cost 0 and n+2 to super sink with cap s cost 0.
Run MCMF and extracting all the full capacity edges in the flow network. https://codeforces.com/contest/730/problem/I

156. Chemistry Experiment (diff=2500, fenwick tree and binary search for final answer)
We use binary search on final answer to solve this problem. We can ask the following question, is it possible for the maximum height to be less than h. Then we observe that only the tubs with height <= h can contribute to the final answer. Suppose that there are cnt tubes with height <= h and the total amount of mercury in them is vol, then we only need to check whether h * cnt >= v + vol.
We might run into precision issue since v can be up to 1e15. We just iterate 80 times to get the answer. The overall complexity would be O(nlognlogv).  https://codeforces.com/contest/431/problem/E

157. Air Raid (theorem: |V| = bipartite matching + minimum edge cover)
https://vjudge.net/problem/UVA-1184

158. Pursuit For Artifacts (diff=2300, tarjan's algorithm and dfs)
By definition of biconnected components, for any two points u, v in the same biconnected components there exists at least 2
path from u->v. Hence, we have the following observation. If there's some artifects in some biconnected components if we can
get in to the components, we can definitly get out in any points we want. So the algorithm works as follows. Firstly, run tarjan's
algorithm to extract all the biconnected components and do point compression to make the graph into a tree. Then the problem
is changed into whether there is a special vertex or an special edges in two given points in a tree. Validating the path u->LCA(u, v)
->v would get the solution. https://codeforces.com/problemset/problem/652/E

159. Segments (diff=2500, sets)
Nothing special about the problem, just maintain a set of disjoint segments to achieved an armotized O(logn) intertion complexity.
https://codeforces.com/contest/926/problem/J

160. Dispute (diff=2100, BFS)
We have the following observation, there's no -1 case, since for every button we only need to press at most once to make the button valid. Hence, we can use BFS by pushing all buttons with value 0 into the queue, and then press the corresponding buttons. 
https://codeforces.com/problemset/problem/242/D

161. Students Initiation (diff=2400, Dinic's algorithm and binary search for final answer)
We can observe that if we define the question as can the final answer be no greater than mid. Then we should easily show that if mid1
satisfy the problem statement then mid2 >= mid1 can definitly satisfy the statement. Hence, we can binary search for final answer.
Note that we can solve this problem by applying maxflow algorithms. Suppose that we want to validate mid, we add edges from the super
source to all n people with edge capacity mid, then suppose that the ith edge has end points v1 and v2, we add edge from v1 to i+n and
v2 to i+n with capacity 1, and finally add edges from the nodes representing edges to the super sink. We just need to validate whether
the final flow is m. The flow network is similar to Ray's problem set question Hard life which again proofs Ray's problem set is
very useful. https://codeforces.com/contest/847/problem/J

162. Take-off Ramps (diff=2400, point compression and dijkstra's algorithm)
The hardest part about this problem is dealing with the p[i]. We build the graph in the following way, firstly note that only
x[i], x[i] + d[i], x[i] - p[i], 0, L are useful points, we connect the adjacent points x1, x2 with weight x2 - x1 bidirectionally. 
A key observation is if we use the ramp i, it is actually equivalent to running from x[i] - p[i] to x[i] using p[i] time and then fly from x[i] to x[i] + d[i] in t[i]. So we can directly connect x[i] - p[i] to x[i] + d[i] with weight t[i] + p[i]. After that, we simply
run dijkstra's algorithm and find the solution. https://codeforces.com/contest/141/problem/D

163. Almost Permutation (diff=2300, MCMF)
Firstly, we can use elimination method to find out for each element at index i, which element can be filled in it. Then, the problem
is changed to for each index select a matching element, and for each element the cost of selecting it is cnt^2. This is a typical MCMF
problem setting. We connects the super source to 1-n and then if the ith element can have a value j we connect i to j+n. Finally, 
we connect 1+n to 2n to the super sink with (cap,cost) of (1, 1), (1,3)...(1, 2n-1). Then run the MCMF to find the solution.
https://codeforces.com/problemset/problem/863/F

164. Card Game (diff=2500, Dinic's algorithm and binary search for final answer)
I was coached by this problem :(. This problem requires 3 observations, 2 of them are quite standard. Firstly, we observe that we can use binary search on final answer to solve this problem. Secondly, min cut on a bipartite graph can validate the answer. However, how can we establish the bipartite graph? The key observation is only 2 = 1 + 1 is the only even prime number, so that we can split the numbers into LHS (all odd numbers), and RHS (all even numbers). For 1, we only keep the one which is valid at the moment and has the maximum p value. Then we simply run any maxflow algorithm would find the solution. https://codeforces.com/contest/808/problem/F

165. Eyes Closed (diff=2500, range tree and probability)
We know that E[l1, r1] = E[l1, r1] * (len1-1) / len1 + E[l2, r2] / len2 and E[l1, r1] = E[l2, r2] * (len2-1) / len2 + E[l1, r1] / len1.
Hence, the problem is changed into a range update and range query problem, a standard range tree would solve it easily. We only need to be careful about the order of lazy propagation. https://codeforces.com/contest/895/problem/E

166. Guess Your Way Out! II (diff=2500, sets)
The observation is we can deal with 1 events and 0 events seperately. For all 1 events, it is like intersection the answer ranges,
for all 0 events, we union the invalid ranges. To maintain the 0 events, we maintain a set of disjointed pairs which support insertion.
After the intersection 1 event range is determined, we do ans = ans - invalid. Note that here, ans and invalid are sets.
https://codeforces.com/contest/558/problem/D

167. Number Sequence (KMP)
https://vjudge.net/problem/HDU-1711

168. Oulipo (KMP)
The hardest part about this problem is overlap counts. Hence, we need to make good use of the next array. Since next is defined as
the longest match of the suffix and the prefix, by drawing some diagrams we can easily figure out that when there's a match, we
simply shift j to next[j-1] and i-- would solve the problem. https://vjudge.net/problem/HDU-1686

169. Cyclic Nacklace (KMP)
The observation is we only need to work out the shortest period prefix of a string. And the period is equal to len - next[len] after
we work out next array using KMP. https://vjudge.net/problem/HDU-3746

170. Period (KMP)
https://vjudge.net/problem/SPOJ-PERIOD

171. Kefa and Watch (diff=2700, range tree and hashing)
A range update should immediately remind us to use range trees. And to answer whether a string of length n has a period of d we know from the KMP algorithm, this is equivalent to checking the substring [1:len-d] is equal to [d+1, len]. To do this is an efficient way,
we could use hash functions. Two strings are called equal if their hash function is equal and in order to get the correct answer with
very very high probability, we can use two hash functions, then the strings are equal if both functions are equal. After that, the
problem is changed into a routine range tree and lazy propagation problem. https://codeforces.com/contest/580/problem/E

172. Power Strings (KMP)
https://vjudge.net/problem/UVA-10298

173. Seek the Name, Seek the Fame (KMP)
This problem examines the understanding of the next array of the KMP algorithm. We can find the next array first and backtrack the 
answer by calling curr = nxt[curr]. https://vjudge.net/problem/POJ-2752

174. Nudist Beach (diff=2300, BFS and binary search for final answer)
The first observation is if we rephrase the question as is it possible for the final answer to be no less than v (0 <= v <= 1), 
we immediately notice that v is monotone. Hence, we can binary search for the final answer. However, another difficulty is how
to create a set of nodes that satisfy the constraints. The most important observation is if we remove the neighbour of a node v,
its strength can only decrease. Hence, we can use BFS strategy and eliminate all nodes that have strength less than v. The main lesson
here is if you cannot construct the answer in a forward direction, try to do it backward. https://codeforces.com/contest/553/problem/D

175. Fools and Foolproof Roads (diff=2500, greedy and union find)
https://codeforces.com/contest/362/problem/D

176. Okabe and City (diff=2200, dijkstra)
This is a standard problem about using dijkstra on state transition. For every point, we consider 3 states, 0 = no light, 1= the row
is lit, 2= the column is lit, then just follow the problem statement to do valid state transition. https://codeforces.com/problemset/problem/821/D

177. Teams Formation (diff=2400, deque and observation)
The key observation is only 4 types of group can be formed. Type 1: groups that are formed by k adjacent unique elements in 1 period, this kind of group should be counted m times for each occurence in the original sequence of length n. Type 2: after groups of type 1 are formed,  groups can be formed by the starting elements of period i+1 and ending elements of period i. And this kind of group should be
counted m-1 times for each occurence of the original sequence. Type 3: if there's a unique remaining elements, new groups that contains
only this element can be formed. Type 4: if there's no remaining elements after the first 3 types of group are formed, the total number
of type 2 should be counted twice (see the last input data). https://codeforces.com/problemset/problem/878/B

178. Spanning Tree with One Fixed Degree (diff=2200, union find)
This is a constructive problem. We firstly join all the points with index greater than 1 without edges that have 1 as an endpoint. 
Then, we join 1 with all connected components once. For the remaining degree, we join 1 with all the connected points that weren't joined in the previous step. Finally, we use union find again on the remaining edges to create the final tree.
https://codeforces.com/contest/1133/problem/F2

179. Mr. Kitayuta's Colorful Graph (diff=2300, union find and observation)
We can consider each color seperately, u can reach v in an undirected graph means if we apply union find procedure, u and v should
end up in the same connected component. Hence, we can establish n sets, for the set i, it records all (p, c) pairs which means
i belongs to the connected component p with color c. Note that to avoid TLE, we only append (p, c) to set i if there's edge(u, i, c)
or edge(i, u, c). After that for each query, it simply asks the size of the intersection of set(u) and set(v), we iterate the 
set with a smaller size to answer the queries. https://codeforces.com/contest/506/problem/D

180. Desk Disorder (diff=2100, union find)
There are only 3 types of connected components, tp1: connected components that forms a functional graph, tp2: connected components
that forms a tree, tp3: connected components with self cycle. For case 1, the ans sould be doubled, case 2, ans could time the number
of vertices in such connected component. Since every vertex has at most 1 outlink, union find can help to detect cycle and self cycle
in this situation. https://codeforces.com/problemset/problem/859/E

181. New Roads (diff=2100, tree and observation)
The problem asks to construct a tree satisfies the ith level consists a[i] nodes and there are k leaf nodes. The key observation is
for every level from 0 to t-1, there must be at least 1 non leaf node and if a[i] > a[i+1], level i must have at least a[i] - a[i+1]
leaf nodes. We can mark the nodes that must be leaf node first and then link the edges. https://codeforces.com/problemset/problem/746/G

182. Place Your Ad Here (diff=2500, line sweep, range tree, set)
The problem asks to compute the largest cost[j] * intersection(interval of type 1, interval of type 2). We can easily classify it as
a line sweep problem. We should do 3 line sweeps in total. The first sweep, we eliminate all the channels that can be fully overlapped
by the videos using a set and update the answer. The second line sweep, we sort all the channels and videos by the r value and
use a range tree to update the answer. Finally, we sort all the channels and videos by the l value and use a range tree to update the
answer. https://codeforces.com/contest/542/problem/A

183. Breaking Good (diff=2200, BFS and dijkstra)
The problem is equivalent to finding the shortest path that has the most amount of 1 edge (i.e. shortest path that has the least amount of 0 edge). We can run 2 BFS first, one from vertex 1, the other from vertex n. Then, we construct a shortest path level graph with k[i] as weights. Finally, we run dijkstra's algorithm to find the shortest weighted path from 1 to n in the level graph we created in the previous step. https://codeforces.com/contest/507/problem/E

184. Information Graph (diff=2400, offline union find)
This problem is very similar to one of Ray's assignment problem. Asking whether x has a type i document is equivalent to asking,
whether at the time document i is signed whether x is the parent of y (the person that initially signed the document). This can
be done efficiently by sorting the queries according to the type-2 event. And then we do a line sweep, for each type-1 event, we union
point x and point y, for each type-3 event we simply see whether x and y is in the same connected component and y is in the subtree
of x. https://codeforces.com/contest/466/problem/E

185. Almost Acyclic Graph (diff=2200, dfs)
This examines the definition of backedge in dfs traversal. https://codeforces.com/contest/915/problem/D

186. Andrew and Taxi (diff=2200, binary search for final answer and top-sort)
The problem is actually asking select the minimum C, such that we only need to select edges with weight less than or equal to C
and reverse some in order to eliminate all the cycles in the graph. We can binary search on this C. However, how to validate the
final answer is quite tricky. Something we might ignore is if we do a top sort on an acyalic graph, if we keep adding edges from
some v1 to v2 which v1 has a top order less than v2, the graph would never contain a cycle. Hence, we can simply find the top
order of the subgraph formed with edges with weight greater than C, and add the remaining edges from a vertex with less top sort order 
to a vertex with greater top sort order. https://codeforces.com/problemset/problem/1100/E

* Feb 12 to Mar 11 --- "virus gap term training" focal point: dynamic programming, greedy and graph

187. Suggested Friends (diff=2200, graph connectivity and brute force)
If we cannot solve the problem if a smart way, the first thing we need to do is analyze the complexity of brute force. And we can see
if we just follow the definition of suggested friend we have a solution that is O(m^2) which m <= 5000, hence the brute force solution would run in time. https://codeforces.com/contest/245/problem/G

188. Tourism (diff=2200, tarjan's algorithm and simple tree dp)
The statement "not use any road twice in a row" should immediately remind us to use tarjan's bridge finding algorithm to compress
the biconnected components into a tree. However, there's something we have to be careful before run a simple tree dp to find the
largest weighted path from root to leaf. If a component size has size greater than 1 and one of its child has component size greater
than 1, one can actually walk down to the child and come back. Hence, in order to reduce the complexity of the dp procedure, 
if a biconnected component has size greater than 1, we recursively merge it to its parent. https://codeforces.com/problemset/problem/1220/E

189. Fishes (diff=2100, priority queue and expected value)
The answer is actually the sum of the k cells that has the largest total contribution. If we draw some examples we can figure out that
these k cells should group together, hence we can use a priority queue and a uninformed cost search that starts from (r, r) to 
find the k largest contributing cells. https://codeforces.com/problemset/problem/912/D

190. Roma and Poker (diff=2100, standard dp)
https://codeforces.com/contest/803/problem/E

191. Counter Attack (diff=2300, union find and range tree graph construction)
Similar to 653E, nothing special. https://codeforces.com/contest/190/problem/E

192. Tree Constructing (diff=2200, graph, construction)
There's an obvious observation, we can construct one diameter first and then add subtrees to the vertices on that diameter.
https://codeforces.com/contest/1003/problem/E

193. Iahub and Xors (diff=2500, 2d-fenwick tree)
I learned something new on 2d data structure :). https://vjudge.net/problem/CodeForces-341D

194. Anti-Palindromize (diff=2500, MCMF)
It is quite obvious that the problem is not a dp problem, so maxflow or MCMF should be our direction. The problem basically has
several constrains, for each letter is should be used exactly cnt_i times, for each position should match exactly 1 letter,
position i and position n-i+1 should have different letters. We can construct the following graph, connect src to nodes representing
a-z with cap= cnt_i, cost=0, create n/2 extra nodes for each letter (a-z), connect a-z to these extra nodes with cap=1, cost=0,
connect the extra nodes to i and n-i+1 (for all i) with cap=1, cost=-b[i] or 0 depending on whether the letter match with s[i] or not.
Finaly connect nodes 1 to n to the sink. Run MCMF would get the correct solution (print the the cost times -1).
https://vjudge.net/problem/CodeForces-884F

195. Evacuation (diff=2500, Dinic's algorithm)
It is obvious that this problem cannot be solved by greedy or dynamic programming, hence we try to construct a flow network. Let's firstly use BFS to compute the shortest distance from 'Z' to all cells. Then let's construct a level graph with t+2 levels. Connect
s to nodes in level 1 with capacity shown in the first grid. Connect level t + 2 nodes to t with capacity shown in the second grid.
Finally for nodes v1 in level i and v2 in level i+1, connect v1 to v2 iff v1 is adjacent to v2 and dist[v1] >= i and dist[v2] >= i.
Run maxflow would get the solution. The main lesson is for this type of very long problems, every sentence should be read carefully,
unless you want to get WA feedback. https://vjudge.net/problem/CodeForces-78E

196. Rectangle Painting 2 (diff=2500, Dinic's algorithm)
The key observation is we can do point compression on rows and columns seperately and partition the entire shape into several rectangle
regions. Then the problem is changed into the following, we can change all regions in some row/col with a given cost, what is the
minimum cost to change required cells black. This is a standard min-cut problem and can be solved by applying Dinic's algorithm.
https://vjudge.net/problem/CodeForces-1198E

197. Bipartite Segments (diff=2500, tarjan's algorithm, fenwick tree and line sweep)
The first observation is there's no nested cycle, so that after we use tarjan's biconnected component algorithm we can represent
each connected component as an interval [l, r], which l is the smallest vertex in that component and r is the largest index vertex
in that component. Then we establish 2 BITs to compute for each left end point i, what is the minimum r without a fully covered
interval. The problem is a quite standard line sweep problem and can be solved in O(nlogn) complexity. 
https://vjudge.net/problem/CodeForces-901C

198. Brackets (interval dp)
We define the sub problem(i, j) as the maximum matching by using brackets in the interval [i, j]. Then we can easily see that
we only need to consider where to partition the matching point. dp[i][j] = max(2match(i, j) + dp[i+1][j-1], dp[i][k] + dp[k+1][j], k=i..j-1) https://vjudge.net/problem/POJ-2955

199. Product Sum (diff=2500, convex-hull trick)
https://vjudge.net/problem/CodeForces-631E

200. Recursive Queries (diff=2500, line sweep and range tree lazy propagation)
The key observation is for each number its contribution is actually equal to qr - ql + 1, which qr refers to the right most position
such that the number is greater than all numbers between itself and qr, similar for ql. Hence, the problem is changed to a line 
sweep problem, we only need to calculate the total contribution of all numbers within the query range. We use range tree and lazy
propagation to solve this twice, once in the forward direction while another iteration in the backward direction.
https://vjudge.net/problem/CodeForces-1117G

201. Multiplication Puzzle (interval dp)
https://vjudge.net/problem/POJ-1651

202. B-number (digit dp)
https://vjudge.net/problem/HDU-3652

203. Bomb (digit dp)
https://vjudge.net/problem/HDU-3555

204. Blood Cousins (diff=2400, dfs and binary-lifting)
The obvious observation is this problem is equivalent to the following. Suppose that nv is the pth parent of v, we need to count
the number of nodes that is in the subtree of nv and has dist(nv, u)=p. For the find pth parent part, we can use binary lifting to do 
it. And for the counting part, we maintain a sorted vector for the dfs order of nodes of each level of the tree, and use binary search to find the left most and right most nodes that are in the same level of v and is in the subtree of nv. This solution works in
O(nlogn + mlogn) https://vjudge.net/problem/CodeForces-208E

205. Balanced Number (digit dp)
https://vjudge.net/problem/HDU-3709

206. AI robots (diff=2200, line sweep and dynamic range tree)
We use two pointers approach, pt1 points to the robot[i].x (in non-decreasing order), pt2 points to robot[i].x + robot[i].r (in
non-decreasing order). Then, before each time we query the total number of points between [robot[i].x - robot[i].r, x], we
delete all the points that its robot[j].x + robot[j].r cannot reach robot[i].x anymore. Using dynamic range tree is definitly
the best for this case, we simply maintain ~10^5 range trees, 1 for each IQ. https://vjudge.net/problem/CodeForces-1045G

207. Subtree Minimum Query (diff=2300, persistent range tree)
The solution is actually very simple, we establish persistent range trees according to the BFS order, and query the corresponding
tree according to the DFS order. https://vjudge.net/problem/CodeForces-893F

208. Mike and Feet (diff=2100, dp or binary search and sparse table)
The only thing I'm amazed with this problem is that I solved a standard dp problem with sparse table and binary search.
https://vjudge.net/problem/CodeForces-547B

209. The Bakery (diff=2200, dp, divide and conquer optimization)
The hardest part is how to calculate the cost(l, r), however, if we are familiar with Mo's algorithm i.e. always maintaing
the current valid window of cost, the problem is very easy to be solved in an amortized O(nklogn) complexity.
https://vjudge.net/problem/CodeForces-833B

210. Lucky Array (diff=2300, sqrt decomposition)
This problem has many solutions, we can either use sqrt decomposition or amortized range tree. https://vjudge.net/problem/CodeForces-121E

211. Quarrel (diff=2400, BFS)
The problem is actually very simple. let dist(i, j) refers to the shortest path to state i, j, then we use BFS to find the minimum
distance from state 1, n to state n, 1 without moving to any state (v, v) in the middle. https://vjudge.net/problem/CodeForces-29E

212. Salazar Slytherin's Locket (diff=2200, digit dp)
The observation is we only need to know how many times each digit occurs after the leading non-zero digit. We can use a bitmask
to represent the odd/even occurence of each digit 0-9. With memorization, we can easily get a complexity of O(q + 11*2^b*log(r)).
https://codeforces.com/problemset/problem/855/E

213. Two permutations (diff=2200, persistent range tree)
https://vjudge.net/problem/CodeForces-323C

214. Case of Fugitive (diff=2100, greedy and line sweep)
The problem can be solved by greedy should be figured out easily, however, how to do it correctly is not that stright forward.
We firstly sort all the gap according to a[i].r - a[i-1].l, and the bridges according to length. Then, we maintain a set of
bridges, which represents all the bridges that can be selected which length are no greater than a[i].r - a[i-1].l. Then, for
each gap we select the shortest bridge that is no less than a[i].l - a[i-1].r and remove the bridge from the set.
https://vjudge.net/problem/CodeForces-555B

215. DZY Loves Modification  (diff=2100, greedy)
Seperate rows and cols. https://vjudge.net/problem/CodeForces-446B

216. Pair of Numbers (diff=2100, math and binary search, sparse table)
The observation is actually very simple, we can validate if a[j] = gcd(l, r), and since as l decrease and r increase gcd(l, r) is
non-increasing, we can use binary search to get the optimal(l, r) for each j. Maintaining gcd(l, r) on a static array can be done
with sparse table. https://codeforces.com/problemset/problem/359/D

217. R2D2 and Droid Army (diff=2100, binary search and sparse table)
https://vjudge.net/problem/CodeForces-514D

218. Mishka and Interesting sum (diff=2100, line sweep and fenwick tree)
We process the queries offline, and always make sure for all numbers, we don't update its last occurrence in the BIT.
https://vjudge.net/problem/CodeForces-703D

219. Messenger Simulator (diff=2100, ordered statistic tree)
We introduce something called key, initially keys are equal to i. For each operation, we simply find the order of (key[v], v),
update max[v] and min[v] and then erase (key[v], v) from the ordered set. Finally, at the end of the operation, we add 
(minkey - 1, v) to the set. https://vjudge.net/problem/CodeForces-1288E

220. Same Sum Blocks (Hard) (diff=2200, data structures and greedy)
We can use prefix array to transform this porblem to a standard greedy problem. Select the maximum
amount of non-intersecting intervals from a group of intervals. https://vjudge.net/problem/CodeForces-1141F2

221. Clique Problem diff=2100, dp and data structures
The observation is, if we sort all the vertices according to x then if xj < xi and xi can connect to xj, then xi can connect
to all points in the clique which j has the largest x coordinate. Then, the rest of the problem is very simple after we rewrite the equation to xi - wi >= xj + wj. If we maintain a range max segment tree on xi+wi and process the points according to x increasing
order, then the problem is changed to a LIS problem, which can be solved easily in O(nlogn) time complexity.
https://vjudge.net/problem/CodeForces-527D

222. Tokitsukaze and Strange Rectangle  (diff=2200, line sweep and combinatory)
This problem is actually very hard. We need to know how to avoid double count for rectangles with the same y coordinate.
https://vjudge.net/problem/CodeForces-1190D

223. Multidimensional Queries (diff=2200, range tree and observation)
Since k <= 5, we can think how to solve this problem when k=1 or k=2. For k=1, we know that we can use divide and conquer range
tree to solve this problem, when we merge two intervals the answer is always lans, rans or lmax-rmin or rmax-lmin, we select
the maximum among those possible answers. Then, we might observe that for absolute values |a-b|, if we brute force all the cases
a > b or a <= b there are in total 1 << 5 cases which isn't too bad. And we also know the answer is the maximum among those
32 combinations. So the answer works as follows, we maintain range max, range min of (+-)b[l][1] (+-)b[l][2] (+-)b[l][3] .. (+-)b[l][k]
and use divide and conquer to merge them. Then final solution would work in O(160n + 32nlogn) which is fast enough.
https://vjudge.net/problem/CodeForces-1093G

224. Boredom (diff=2200, persistent range tree and combinatory)
https://vjudge.net/problem/CodeForces-853C

225. Arson In Berland Forest  (diff=2200, BFS and binary search on final answer)
There should be a health warning for this problem, it is absolutely a TLE giver.
https://vjudge.net/problem/CodeForces-1227E

226. Beard Graph (diff=2200, preparation for HLD)
https://vjudge.net/problem/CodeForces-165D

227. Drazil and Morning Exercise (diff=2800, persistent range tree, kruskal modification and tree dp)
We should immediately realize that q is only 50, which means that we can process the queries seperately. Firstly, let's do some 
precomputations, we preprocess the longest path (cost[i]) from every vertex i to a leaf using 2 dfs. Secondly, we use the kruskal modification algorithm, to produce a tree that satisfy for each node v every nodes u in its subtree has cost[u] >= cost[v].
Then the problem is changed to the following, we need to find the total number of nodes that's in the subtree of v which has cost
no greater than cost[v] + L. And we should realize that persistent range tree is perfect for this. 
https://codeforces.com/contest/516/problem/D

228. Round Subset (diff=2100, knapsack dp)
The observation is we can extract all the 2, 5 factor of a[1..n], then we define the subproblem as opt(i, j, k) be the maximum
number of factor 2 when select k numbers from the first i numbers with j fac 5. https://vjudge.net/problem/CodeForces-837D

229. Thwarting Demonstrations (diff=2200, fenwick tree and binary search for final answer)
This trick is too simple, just don't forget to push in 0 to the disc array when doing point compression. https://vjudge.net/problem/CodeForces-191E
