# codeforce practice
codeforce practice summary update everyday

* Aug 30 to Sep8:


1. Rooks and Rectangles (div1, diff=2400, segmenttree and line sweep)
http://codeforces.com/problemset/problem/524/E

2. Cannon (div2, diff=2100, two pointers)
http://codeforces.com/problemset/problem/47/E

3. Buses and People (div2, diff=2400, segmenttree and line sweep)
https://codeforces.com/contest/160/problem/E

4. Summer Homework (diff=2500, segmenttree and math)
http://codeforces.com/problemset/problem/316/E3

5. Sum of Medians (diff=2200, segmenttree and divide and conquer)
https://codeforces.com/problemset/problem/85/D

6. Fire (div2, diff=2000, dynamic programming)
http://codeforces.com/problemset/problem/864/E

7. Package Delivery (div1/2, diff=2300, greedy)
https://codeforces.com/problemset/problem/627/C

8. Let Them Slide (div1/2, diff=2200, segmenttree and lazypropagation)
http://codeforces.com/problemset/problem/1208/E

9. Stripe 2 (codeforces round #21, diff=2300, dynamic programming)
http://codeforces.com/problemset/problem/21/C

10. Bulmart (2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest, diff=2200, greedy and binary search)
http://codeforces.com/problemset/problem/730/C

11. Preparing for the Contest (div1, diff=2100, greedy and binary search)
http://codeforces.com/problemset/problem/377/B

12. GukiZ hates Boxes (div2, diff=2200, greedy and binary search)
https://codeforces.com/problemset/problem/551/C

13. Stressful Training (div2, diff=2300, greedy and binary search)
http://codeforces.com/problemset/problem/1132/D

14. On Changing Tree (div1, diff=2400, segmenttree and dfs)
http://codeforces.com/contest/396/problem/C

* Sep 9 to Sep 16:


15. Frogs and mosquitoes (div2, diff=2500, segmenttree, greedy and set)
http://codeforces.com/contest/609/problem/F

16. Noise Level (div2, diff=2000, graph, bfs)
http://codeforces.com/contest/847/problem/I

17. Reachability from the Capital (div3, diff=1900, strongly connected component)
http://codeforces.com/contest/999/problem/E

18. Checkposts (div2, diff=1700, strongly connected component)
https://codeforces.com/contest/427/problem/C

19. Inna and Binary Logic (div2, diff=2400, segment tree and divide and conquer)
https://codeforces.com/contest/400/problem/E

20. Online Courses In BSU (VK Cup 2017 - Qualification 2, diff=1900, topological sort)
https://codeforces.com/contest/770/problem/C

21. The Child and Sequence (div2, diff=2300, segment tree and math)
https://codeforces.com/contest/438/problem/D

22. Closest Equals (VK Cup 2015 - Qualification Round 1, diff=2200, segment tree and sliding windows)
https://codeforces.com/contest/522/problem/D

23. One Occurrence (div2, diff=2400, segment tree and two pointers)
https://codeforces.com/problemset/problem/1000/F

24. Vasya and a Tree (div2, diff=1900, dfs definition and offline segment tree)
https://codeforces.com/problemset/problem/1076/E

25. Little Elephant and Tree (div1, diff=2400, dfs and offline segment tree)
https://codeforces.com/problemset/problem/258/E

26. Water Tree (div1, diff=2100, dfs and segment tree)
https://codeforces.com/contest/343/problem/D


* Sep 17 to Sep 23:

27. Buy a Ticket (div2, diff=2000, graph modification and dijkstra)
https://codeforces.com/contest/938/problem/D

28. 0-1-Tree (div2, diff=2300, tree DP) this problem needs more working on it!
https://codeforces.com/contest/1156/problem/D

29. Please, another Queries on Array? (div2, diff=2500, segment tree, bitset and math)
https://codeforces.com/problemset/problem/1114/F

30. Misha, Grisha and Underground (div2, diff=1900, math and lca using rmq)
https://codeforces.com/contest/832/problem/D

31. Kilani and the Game (div2, diff=1900, bfs) 
https://codeforces.com/problemset/problem/1105/D

32. Bertown roads (div2, diff=2100, tarjan's bridge finding algorithm)
https://codeforces.com/problemset/problem/118/E

* Sep 24 to Sep 30:

33. Scheme (div2, diff=2400, tarjan's scc and point compression)
https://codeforces.com/contest/22/problem/E

34. Roads not only in Berland (div2, diff=1900, Kruskal MST)
https://codeforces.com/problemset/problem/25/D

* Oct 1 to Oct 7:

35. Legency (div1, diff=2600, segment tree and dijkstra)
https://codeforces.com/problemset/problem/786/B

36. Paths and Trees (div2, diff=2100, dijkstra)
https://codeforces.com/problemset/problem/545/E

37. st- spanning tree (div2, diff=2200, kruskal and greedy)
https://codeforces.com/problemset/problem/723/F

38. Queue (Codeforces Beta Round, diff=2300, AVL tree)
https://codeforces.com/contest/38/problem/G

* Oct 8 to Oct 13:

39. The Shortest Statement (div2, diff=2300, dijkstra and LCA) 
https://codeforces.com/problemset/problem/1051/F

40. Strictly Positive Matrix (div2, diff=2200, tarjan scc and math)
https://codeforces.com/problemset/problem/402/E

41. Analysis of Pathes in Functional Graph (div2, diff=2100, binary lifting) 
https://codeforces.com/problemset/problem/702/E

42. We Need More Bosses (div2, diff=2100, tarjan and tree dp)
https://codeforces.com/problemset/problem/1000/E

* Oct 14 to Oct 20:

43. Beautiful numbers (div2, diff=2400, dight dp)
https://codeforces.com/problemset/problem/55/D

44. Magic Numbers (div2, diff=2200, digit dp)
https://codeforces.com/problemset/problem/628/D

45. Roman and Numbers (div2, diff=2000, digit dp and bitmask)
https://codeforces.com/problemset/problem/401/D

46. Segment Sum (div2, diff=2300, digit dp and bitmask)
https://codeforces.com/problemset/problem/1073/E

* Oct 21 to Oct 27:

47. Ilya and Roads (div2, diff=2100, DP and greedy)
https://codeforces.com/problemset/problem/313/D

48. Lunar New Year and Red Envelopes (div2, diff=2100, DP and line sweep)
https://codeforces.com/problemset/problem/1106/E

49. Sequence (Codeforces Beta Round #13, diff=2200, DP)
https://codeforces.com/contest/13/problem/C

50. Bad Luck Island (div2, diff=2100, DP and probability)
https://codeforces.com/contest/540/problem/D

51. Linear Kingdom Race (div1, diff=2400, DP and segment tree and line sweep)
https://codeforces.com/contest/115/problem/E

52. Trains and Statistic (div2, diff=2500, DP and segment tree and greedy) 
https://codeforces.com/contest/675/problem/E

53. Bear and Tree Jumps (VK Cup 2017 - Round 1, diff=2100, tree DP)
https://codeforces.com/problemset/problem/771/C

* OCt 28 to Nov 3:

54. Coloring Brackets (div2, diff=2200, interval DP) 
https://codeforces.com/contest/149/problem/D

55. Periodic RMQ Problem (Educational Codeforces Round 20, diff=2500, segment tree and point compression)
https://codeforces.com/contest/803/problem/G

* Nov 17 to Nov 24:

56. Cow (Poj2481, line sweep and fenwick tree)
https://vjudge.net/problem/POJ-2481

57. Stars in Your Window (Poj2482, line sweep and segment tree lazy propagation)
https://vjudge.net/problem/POJ-2482

58. Camping Groups (Croc Champ 2012 - Round 1, line sweep & fenwick tree & segment tree, diff=2600)
https://codeforces.com/contest/173/problem/E

* Nov 25 to Dec 11:

59. A and B and Lecture Rooms (div2, diff=2300, LCA and dfs)
https://codeforces.com/contest/519/problem/E

60. Road Improvement (div1, diff=2300, dp // worst problem I've ever seen)
https://codeforces.com/problemset/problem/543/D

61. Little Elephant and Inversions (div1, diff=2400, fenwick tree and line sweep) 
https://codeforces.com/contest/220/problem/E

62. Yaroslav and Divisors (div1, diff=2200, fenwick tree and line sweep) 
https://codeforces.com/contest/301/problem/D

63. Bear and Bowling 4 (Educational Codeforces Round 11, diff=2500, convex-hull and dp)
https://codeforces.com/contest/660/problem/F

64. Tree (div1 + div2, diff=2200, binary-lifting and dp) 
https://codeforces.com/contest/932/problem/D

65. Send the Fool Further! (medium) (Helvetic Coding Contest 2017, diff=2100, tree dp) 
https://codeforces.com/contest/802/problem/K

66. Tree with Maximum Cost (div3, diff=2100, tree dp)
https://codeforces.com/contest/1092/problem/F

* Dec 12 to Feb 11 summer holiday training --- data structure + graph + string  

67. Dog Food (div2, diff=2300, greedy)
https://codeforces.com/contest/847/problem/D

68. Berland University (diff=2100, greedy and binary search)
https://codeforces.com/contest/1090/problem/L

69. Complete The Graph (diff=2200, dijkstra)
https://codeforces.com/problemset/problem/715/B

70. Three States (diff=2200, dijkstra)
https://codeforces.com/problemset/problem/590/C

71. Case of Chocolate (diff=2500, range tree)
https://codeforces.com/problemset/problem/555/C

72. REQ (diff=2500, range tree and sweeping and number theory)
https://codeforces.com/problemset/problem/594/D

73. Wires (diff=2200, graph and dfs)
https://codeforces.com/problemset/problem/1250/N

74. Petya and Graph (diff=2400, Dinic's algorithm and maximum enclosure graph)
https://codeforces.com/problemset/problem/1082/G

75. Jeff and Removing Periods (diff=2700, fenwick tree, line sweep)
https://codeforces.com/contest/351/problem/D

76. Soldier and Traveling (diff=2300, Dinic's algorithm and extracting flow)
https://codeforces.com/contest/546/problem/E

77. Exploration plan (diff=2400, Dinic's algorithm and Floyd algorithm and binary search for final answer)
https://codeforces.com/problemset/problem/852/D

78. Valera and Queries (diff=2400, fenwick tree, line sweep)
https://codeforces.com/problemset/problem/369/E

79. Minimal Labels (diff=2400, greedy and topological sort)
https://codeforces.com/problemset/problem/825/E

80. Diverging Directions (diff=2100, LCA and range tree and dfs)
https://codeforces.com/problemset/problem/838/B

81. Flipping Frustration (extended euclidian algorithm)
https://vjudge.net/problem/UVA-11312

82. Airport Express (dijkstra, path construction)
https://vjudge.net/problem/UVA-11374

83. Drivers Dissatisfaction (diff=2500, Kruskal, greedy, LCA)
https://codeforces.com/contest/733/problem/F

84. Tourist Reform (diff=2400, tarjan's algorithm, bridge finding and biconnected component)
https://codeforces.com/contest/732/problem/F

85. Robots in a DAG (codechef, Dinic's algorithm, construct flow graph in stages)
https://www.codechef.com/problems/ROBOTDAG

86. The K-League (uva, Dinic's algorithm, allocation problem)
https://vjudge.net/problem/UVA-1306

87. Gripping Story (diff=2400, range tree, amortized complexity and searching)
https://codeforces.com/problemset/problem/198/E

88. Radio stations (diff=2400, line sweep and dynamic range tree)
https://codeforces.com/problemset/problem/762/E

89. Developing Game (diff=2400, line sweep and range tree, solved after reading solutions, problem reduction part is stunning)
https://codeforces.com/contest/377/problem/D

90. Army Creation (diff=2300, persistent range tree)
https://codeforces.com/problemset/problem/813/E

91. Board Game (diff=2400, range tree searching, BFS) 
https://codeforces.com/problemset/problem/605/D

92. DQUERY (spoj, Mo's algorithm (range tree/fenwick tree definitly works but Mo's algorithm is excited))
https://vjudge.net/problem/SPOJ-DQUERY

93. Tree and Queries (diff=2400, Mo's algorithm)
https://codeforces.com/contest/375/problem/D

94. Tempter of the Bone (hdu, dfs and backtracking and pruning)
https://vjudge.net/problem/HDU-1010

95. Hot is Cold (diff=2400, range tree and 2-tag lazy propagation, exactly the same technique as codeforce817f MEX query)
https://codeforces.com/problemset/problem/1146/E

96. K-th Number (poj, persistent range tree, searching)
https://vjudge.net/problem/POJ-2104

97. George and Cards (diff=2500, sparse table and fenwick tree and binary search)
https://codeforces.com/contest/387/problem/E

98. Destiny (diff=2400, persistent range tree finding kth largest number and observation)
https://codeforces.com/problemset/problem/840/D

99. Startup Funding (diff=2400, binary search and sparse table and probability)
https://codeforces.com/problemset/problem/633/E

100. Traffic Jams in the Land (diff=2400, range tree, divide and conquer, math observation)
https://codeforces.com/contest/498/problem/D

101. Fire in the City (diff=2500, line sweep and binary search for final answer)
https://codeforces.com/contest/845/problem/E

102. Yet Another Multiple Problem (2012 chengdu regional contest, BFS on numbers)
https://vjudge.net/problem/UVA-1653

103. Angry Programmer (uva, a very simple max flow problem on vertex capacity)
https://vjudge.net/problem/UVA-11506

104. Sorting It All Out (poj, uniqueness of top-sort)
https://vjudge.net/problem/POJ-1094

105. A Famous Grid (spoj, SIEVE and BFS, create a larger grid to deal with the walk out case!)
https://vjudge.net/problem/SPOJ-SPIRALGR

106. Mushroom Gnomes - 2 (diff=2500, range tree and probability)
https://codeforces.com/contest/138/problem/C

107. Following Orders (uva, top-sort BFS approach with backtracking, extracting all top-sort order in dictionary order, good template)
https://vjudge.net/problem/UVA-124

108. Nastya and King-Shamans (diff=2600, range tree and pruning, learned a valuable lesson in time complexity analysis)
https://codeforces.com/contest/992/problem/E

109. Functions on the segments (diff=2600, persistent range tree, solved after getting feedback for 9 times! Note that if only single point value is required we don't need lazy tag!)
https://codeforces.com/contest/837/problem/G

110. Hanger (diff=2300, set and fenwick tree)
https://codeforces.com/problemset/problem/74/D

111. Trip to Saint Petersburg (diff=2300, line sweep and range tree and lazy porpagation, this problem is similar to 115E linear kingdom race)
https://codeforces.com/problemset/problem/1250/C

112. Choose a Square (diff=2500, line sweep and range tree and lazy propagation, another problem similar to 115E linear kingdom race)
https://codeforces.com/contest/1221/problem/F

113. Parking Lot (diff=2500, set and implementation)
https://codeforces.com/problemset/problem/219/E

114. The doors (uva, simple geometry and bellman-ford algorithm, remember the special case for judging two intervals intersection)
https://vjudge.net/problem/UVA-393

115. Queue in the Train (diff=2300, line sweep and priority queue optimization, how to order the event is very important)
https://codeforces.com/contest/1239/problem/C

116. Heidi and the Turing Test (Medium) (diff=2300, line sweep and range tree, change the coordinate system)
https://codeforces.com/problemset/problem/1184/C2

117. Performance Review (diff=2300, range tree and lazy propagation, key observation: the value itself is useless, only >, < matters)
https://codeforces.com/contest/1252/problem/G

118. King Kog's Reception (diff=2400, range tree and divide and conquer)
https://codeforces.com/contest/1089/problem/K

119. Cave Raider (bellman-ford algorithm, shortest path with constraints on path entry time)
https://vjudge.net/problem/POJ-1613

120. Segment Tree (diff=2100, graph connectivity, union find, range tree, complexity analysis, sweeping)
https://codeforces.com/contest/1278/problem/D

121. Find a Number (diff=2200, BFS on remainder, same trick as "Yet Another Multiple Problem")
https://codeforces.com/problemset/problem/1070/A

122. More Queries to Array... (diff=2600, range tree and lazy propagation and binomial theorem)
https://codeforces.com/problemset/problem/266/E

123. Connected Components? (diff=2100, dfs and union-find and range tree to create the graph)
https://codeforces.com/contest/920/problem/E

124.  Bear and Forgotten Tree 2 (diff=2400, dfs and union-find and range tree graph creation, similar to the previous one just with more observation) 
https://codeforces.com/contest/653/problem/E

125. Shortest Path (diff=2100, shortest path, some trick when doing relaxation)
https://codeforces.com/contest/59/problem/E

126. Greedy Elevator (diff=2500, fenwick tree and set, good implementation problem)
https://codeforces.com/contest/257/problem/E

127. Intervals (uva, system of different constraints)
https://vjudge.net/problem/UVA-1723

128. Sereja and Straight Lines (diff=2400, binary search for final answer and line sweep, similar to 845E and 1184C2)
https://codeforces.com/contest/314/problem/D

129. King (central Euro 1997, system of different constraints)
https://vjudge.net/problem/POJ-1364

130. XOR and Favorite Number (diff=2300, Mo's algorithm, need to be very clear on what [l, r] means when maintaining prefix sum)
https://codeforces.com/contest/617/problem/E

131. Cutting a Fence (diff=2400, probability and range tree and lazy propagation on arithmetic progression)
https://codeforces.com/contest/212/problem/D

132. Little Elephant and Shifts (diff=2300, map and math observation)
https://codeforces.com/problemset/problem/220/C

133. Powerful Array (diff=2700, Mo's algorithm)
https://codeforces.com/contest/86/problem/D

134. Serega and Fun (diff=2600, sqrt decomposition, I'm not familiar with deque STL access method which caused me getting WA feedback for 4 times)
https://codeforces.com/contest/455/problem/D

135. Music in Car (diff=2500, line sweep and sets, I think this problem requires some implementation techniques, for example creating
two structs instead of using functions to handle the time addition event would make our life a lot easier)
https://codeforces.com/contest/746/problem/F

136. Play on Words (central Europe, union find and Euler path existence checking, I think the most important observation is using words as "edges" of the graph) https://vjudge.net/problem/UVA-10129

137. Cardboard Box (diff=2500, greedy and fenwick tree, I was killed by this problem :( )
This problem requires the following greedy observation, suppose that an optimal solution has the maximum b[k] at index k, then
we could proof that all [1:k] have been selected at least for level 1. Then the problem is quite routine, using fenwick tree and
binary search would easily give a solution of O(n*logn*logn).
https://codeforces.com/contest/436/problem/E

138. Catenyms (least alphabetical ordered Euler path and Hierholzer's algorithm)
https://vjudge.net/problem/UVA-10441

139. Bear and Contribution (diff=2500, greedy and priority queue)
I wasted valuable time because of ignoring the fact that the final T can be a number not in the given array.
This problem has a very trivial greedy observation which is we need to select k numbers that has the minimum cost to increase
them to T. However, we need to be aware how to maintain a window of k numbers with minimum cost, using priority queue here is
definitly the best choice. https://codeforces.com/contest/639/problem/D

140. Working routine (diff=2600, linked list)
This problem requires some implementation technique, firstly since n = 1000, m = 1000 and q = 10000, we know that O((m+n)q) is
good enough to pass the tests. Note that swapping two submatrix only require to change the connection links. Hence, linked-list
is the best data structure for this type of query. https://codeforces.com/contest/706/problem/E

141. Donkey and Stars (diff=2600, line sweep and geometry and range tree)
This problem taught me some valuable lessons even if I solved it without the support of any solutions. 1. when we are solving
geometry problems, use "/" as few as possible to eliminate TLE. 2. pair<int, index (int)> would be more efficient than pair<int, object> when making a pair. Beyond that, this problem is still very nice. We firstly changed the problem to a LIS problem by math observation,
and after that since the > is defined by two conditions, we can use the standard trick of range tree and line sweep to solve it.
https://codeforces.com/contest/249/problem/D

142. Trips (diff=2100, graph connectivity, working backward and sets)
This graph problem is very interesting. The key observation is when i increases from 1 to m, the tourist set size can only increase.
Hence, we can work backward, firstly add in all the edges. Then, we delete all the edges one by one and always see whether there's an
element with degree less than k, if so eliminate the element. https://codeforces.com/problemset/problem/1037/E

143. Bribes (diff=2300, dfs and LCA and prefix sum)
I got WA for 3 times because of solving a different problem! There's an obvious observation that we only need to know how many times
each road is used. Hence, we use the prefix sum technique that was used in on changing tree.

144. World Tour (diff=2100, BFS and path construction)
This problem has the following observation. If you fix the 2nd and 3rd point, we only need to find the valid 1st and 4th point,
with maximum dist(1, 2) + dist(3, 4) + dist(2, 3). Hence, we can run a BFS to find the pair-wise shortest path, then we might realize
that maximum dist(1, 2) and dist(3, 4) might contain duplicate points (e.g. pt(1) == pt(3)) which is invalid, we need to record
3 points i with maximum distance dist(i, v) / dist(v, i) for each v. https://codeforces.com/contest/666/problem/B

145. Ratings and Reality Shows (diff=2500, range tree and divide and conquer)
I got WA for 4 times and fixed the code for 1.5 hours because of a long long :( . This problem could be solved by using range tree
and divide and conquer. The observation is we only need to make sure the following two values are not less than 0: 1) start +
min_prefix up to t 2) start + prefix up to t + range min sum start from t end at t + len - 1. 
https://codeforces.com/contest/887/problem/D

146. Polycarp and Hay (diff=2100, union-find and dfs)
The observation is since there is a number that must be fixed, we can sort the numbers in the grid which are factors of k in decreasing
order, then the problem is reduced to determine whether there exists a connected component which contains no less than k / g[i][j] numbers, then a union-find and dfs would simply do the job. https://codeforces.com/contest/659/problem/F

147. MST Unification (diff=2300, Kruskal and LCA, binary lifting)
The trick Ray covered in the problem set on MST is very useful. I've already solved more than 3 problems using this trick.
https://codeforces.com/contest/1108/problem/F

148. Optimal Milking (binary search for final answer, Dinic's algorithm)
This problem is similar to codeforce852d, we firstly preprocess all the pair-wise shortest path using Floyd algorithm. Then we binary
search the final answer and use Dinic's algorithm to validate. https://vjudge.net/problem/POJ-2112

149. Panic Room (min-cut)
This problem is very easy. It just asks whether some vertices can all be seperated from a given sink. Add a super source and connects
to all the vertices need to be seperated with INF, connect the forward edges with capacity 1 and backward edges with capacity INF. Then
just run Dinic's algorithm would find the solution. https://vjudge.net/problem/UVALive-3632

150. Cup Trick (diff=2500, balanced tree)
The observation for this problem is there are two cases the task cannot be fulfilled. 1) when you try to move the kth position cup i
to the front, there's a cup j != i at position k. 2) the ith cup is at some other location. Hence, we need to design a data structure
that supports the following 1) insert an element 2) delete an element 3) find the kth smallest element. Any type of balanced tree would
work. However, ordered statistic tree is very slow :(, I wrote an AVL tree and used some fast io techniques to pass the tests.
https://codeforces.com/contest/420/problem/D

151. Kaka's Matrix Travels (MCMF)
This problem verifies the correctness of the MCMF template. Since all points can be walked trough k times, with 1 time that can achieve 
the profit, we set each vertex with a vertex capacity of 1 and vertex cost of v. Then run the MCMF algorithm would find the solution.
https://vjudge.net/problem/POJ-3422

152. Going Home (MCMF)
https://vjudge.net/problem/UVALive-3198

153. Build String (diff=2100, MCMF)
This problem is quite easy. Just add nodes to represent sentences and connect the source to it with cap=a[i] and cost=0,
add the sentence to the a-z nodes with the word count and cost=i, then add the a-z nodes to the target with cost=0, cap=target_cnt.
https://codeforces.com/contest/237/problem/E

154. Binary Tree on Plane (diff=2400, MCMF)
This is the kind of problem we think it is impossible to be done without flow. If we think this might be a flow problem, we have 
the following observation. For a binary tree, each node has at most 2 outlink and at most 1 in link. And for n points if it is a
tree, it must have n-1 points with 1 in link. Hence, we can create the flow graph as follows, add edges with cap 2 and cost 0,
from the super source to all the in vertices, add edges with cap 1 and cost equals to the Euclidian distance from the in vertices
to the out vertices that below them, finally add edges with cap 1 and cost 0 from the out vertices to the super sink. Run MCMF would
give the correct solution. https://codeforces.com/problemset/problem/277/E

155. Olympiad in Programming and Sports (diff=2200, MCMF)
I don't know how to solve this problem using an O(n^2) dp, hence, I'm using MCMF to solve it. The flow establish process looks as
follows. Add a super source connects to all 1-n person with cap 1 cost 0, add all 1-n person to the node n+1 with cap 1 cost a[i],
similarly to n+2 with cap 1 cost b[i]. Finally connects n+1 to super sink with cap p cost 0 and n+2 to super sink with cap s cost 0.
Run MCMF and extracting all the full capacity edges in the flow network. https://codeforces.com/contest/730/problem/I

156. Chemistry Experiment (diff=2500, fenwick tree and binary search for final answer)
We use binary search on final answer to solve this problem. We can ask the following question, is it possible for the maximum height to be less than h. Then we observe that only the tubs with height <= h can contribute to the final answer. Suppose that there are cnt tubes with height <= h and the total amount of mercury in them is vol, then we only need to check whether h * cnt >= v + vol.
We might run into precision issue since v can be up to 1e15. We just iterate 80 times to get the answer. The overall complexity would be O(nlognlogv).  https://codeforces.com/contest/431/problem/E

157. Air Raid (theorem: |V| = bipartite matching + minimum edge cover)
https://vjudge.net/problem/UVA-1184

158. Pursuit For Artifacts (diff=2300, tarjan's algorithm and dfs)
By definition of biconnected components, for any two points u, v in the same biconnected components there exists at least 2
path from u->v. Hence, we have the following observation. If there's some artifects in some biconnected components if we can
get in to the components, we can definitly get out in any points we want. So the algorithm works as follows. Firstly, run tarjan's
algorithm to extract all the biconnected components and do point compression to make the graph into a tree. Then the problem
is changed into whether there is a special vertex or an special edges in two given points in a tree. Validating the path u->LCA(u, v)
->v would get the solution. https://codeforces.com/problemset/problem/652/E

159. Segments (diff=2500, sets)
Nothing special about the problem, just maintain a set of disjoint segments to achieved an armotized O(logn) intertion complexity.
https://codeforces.com/contest/926/problem/J

160. Dispute (diff=2100, BFS)
We have the following observation, there's no -1 case, since for every button we only need to press at most once to make the button valid. Hence, we can use BFS by pushing all buttons with value 0 into the queue, and then press the corresponding buttons. 
https://codeforces.com/problemset/problem/242/D

161. Students Initiation (diff=2400, Dinic's algorithm and binary search for final answer)
We can observe that if we define the question as can the final answer be no greater than mid. Then we should easily show that if mid1
satisfy the problem statement then mid2 >= mid1 can definitly satisfy the statement. Hence, we can binary search for final answer.
Note that we can solve this problem by applying maxflow algorithms. Suppose that we want to validate mid, we add edges from the super
source to all n people with edge capacity mid, then suppose that the ith edge has end points v1 and v2, we add edge from v1 to i+n and
v2 to i+n with capacity 1, and finally add edges from the nodes representing edges to the super sink. We just need to validate whether
the final flow is m. The flow network is similar to Ray's problem set question Hard life which again proofs Ray's problem set is
very useful. https://codeforces.com/contest/847/problem/J

162. Take-off Ramps (diff=2400, point compression and dijkstra's algorithm)
The hardest part about this problem is dealing with the p[i]. We build the graph in the following way, firstly note that only
x[i], x[i] + d[i], x[i] - p[i], 0, L are useful points, we connect the adjacent points x1, x2 with weight x2 - x1 bidirectionally. 
A key observation is if we use the ramp i, it is actually equivalent to running from x[i] - p[i] to x[i] using p[i] time and then fly from x[i] to x[i] + d[i] in t[i]. So we can directly connect x[i] - p[i] to x[i] + d[i] with weight t[i] + p[i]. After that, we simply
run dijkstra's algorithm and find the solution. https://codeforces.com/contest/141/problem/D

163. Almost Permutation (diff=2300, MCMF)
Firstly, we can use elimination method to find out for each element at index i, which element can be filled in it. Then, the problem
is changed to for each index select a matching element, and for each element the cost of selecting it is cnt^2. This is a typical MCMF
problem setting. We connects the super source to 1-n and then if the ith element can have a value j we connect i to j+n. Finally, 
we connect 1+n to 2n to the super sink with (cap,cost) of (1, 1), (1,3)...(1, 2n-1). Then run the MCMF to find the solution.
https://codeforces.com/problemset/problem/863/F

164. Card Game (diff=2500, Dinic's algorithm and binary search for final answer)
I was coached by this problem :(. This problem requires 3 observations, 2 of them are quite standard. Firstly, we observe that we can use binary search on final answer to solve this problem. Secondly, min cut on a bipartite graph can validate the answer. However, how can we establish the bipartite graph? The key observation is only 2 = 1 + 1 is the only even prime number, so that we can split the numbers into LHS (all odd numbers), and RHS (all even numbers). For 1, we only keep the one which is valid at the moment and has the maximum p value. Then we simply run any maxflow algorithm would find the solution. https://codeforces.com/contest/808/problem/F

165. Eyes Closed (diff=2500, range tree and probability)
We know that E[l1, r1] = E[l1, r1] * (len1-1) / len1 + E[l2, r2] / len2 and E[l1, r1] = E[l2, r2] * (len2-1) / len2 + E[l1, r1] / len1.
Hence, the problem is changed into a range update and range query problem, a standard range tree would solve it easily. We only need to be careful about the order of lazy propagation. https://codeforces.com/contest/895/problem/E

166. Guess Your Way Out! II (diff=2500, sets)
The observation is we can deal with 1 events and 0 events seperately. For all 1 events, it is like intersection the answer ranges,
for all 0 events, we union the invalid ranges. To maintain the 0 events, we maintain a set of disjointed pairs which support insertion.
After the intersection 1 event range is determined, we do ans = ans - invalid. Note that here, ans and invalid are sets.
https://codeforces.com/contest/558/problem/D

167. Number Sequence (KMP)
https://vjudge.net/problem/HDU-1711

168. Oulipo (KMP)
The hardest part about this problem is overlap counts. Hence, we need to make good use of the next array. Since next is defined as
the longest match of the suffix and the prefix, by drawing some diagrams we can easily figure out that when there's a match, we
simply shift j to next[j-1] and i-- would solve the problem. https://vjudge.net/problem/HDU-1686

169. Cyclic Nacklace (KMP)
The observation is we only need to work out the shortest period prefix of a string. And the period is equal to len - next[len] after
we work out next array using KMP. https://vjudge.net/problem/HDU-3746

170. Period (KMP)
https://vjudge.net/problem/SPOJ-PERIOD

171. Kefa and Watch (diff=2700, range tree and hashing)
A range update should immediately remind us to use range trees. And to answer whether a string of length n has a period of d we know from the KMP algorithm, this is equivalent to checking the substring [1:len-d] is equal to [d+1, len]. To do this is an efficient way,
we could use hash functions. Two strings are called equal if their hash function is equal and in order to get the correct answer with
very very high probability, we can use two hash functions, then the strings are equal if both functions are equal. After that, the
problem is changed into a routine range tree and lazy propagation problem. https://codeforces.com/contest/580/problem/E

172. Power Strings (KMP)
https://vjudge.net/problem/UVA-10298

173. Seek the Name, Seek the Fame (KMP)
This problem examines the understanding of the next array of the KMP algorithm. We can find the next array first and backtrack the 
answer by calling curr = nxt[curr]. https://vjudge.net/problem/POJ-2752

174. Nudist Beach (diff=2300, BFS and binary search for final answer)
The first observation is if we rephrase the question as is it possible for the final answer to be no less than v (0 <= v <= 1), 
we immediately notice that v is monotone. Hence, we can binary search for the final answer. However, another difficulty is how
to create a set of nodes that satisfy the constraints. The most important observation is if we remove the neighbour of a node v,
its strength can only decrease. Hence, we can use BFS strategy and eliminate all nodes that have strength less than v. The main lesson
here is if you cannot construct the answer in a forward direction, try to do it backward. https://codeforces.com/contest/553/problem/D

175. Fools and Foolproof Roads (diff=2500, greedy and union find)
https://codeforces.com/contest/362/problem/D

176. Okabe and City (diff=2200, dijkstra)
This is a standard problem about using dijkstra on state transition. For every point, we consider 3 states, 0 = no light, 1= the row
is lit, 2= the column is lit, then just follow the problem statement to do valid state transition. https://codeforces.com/problemset/problem/821/D

177. Teams Formation (diff=2400, deque and observation)
The key observation is only 4 types of group can be formed. Type 1: groups that are formed by k adjacent unique elements in 1 period, this kind of group should be counted m times for each occurence in the original sequence of length n. Type 2: after groups of type 1 are formed,  groups can be formed by the starting elements of period i+1 and ending elements of period i. And this kind of group should be
counted m-1 times for each occurence of the original sequence. Type 3: if there's a unique remaining elements, new groups that contains
only this element can be formed. Type 4: if there's no remaining elements after the first 3 types of group are formed, the total number
of type 2 should be counted twice (see the last input data). https://codeforces.com/problemset/problem/878/B

178. Spanning Tree with One Fixed Degree (diff=2200, union find)
This is a constructive problem. We firstly join all the points with index greater than 1 without edges that have 1 as an endpoint. 
Then, we join 1 with all connected components once. For the remaining degree, we join 1 with all the connected points that weren't joined in the previous step. Finally, we use union find again on the remaining edges to create the final tree.
https://codeforces.com/contest/1133/problem/F2

179. Mr. Kitayuta's Colorful Graph (diff=2300, union find and observation)
We can consider each color seperately, u can reach v in an undirected graph means if we apply union find procedure, u and v should
end up in the same connected component. Hence, we can establish n sets, for the set i, it records all (p, c) pairs which means
i belongs to the connected component p with color c. Note that to avoid TLE, we only append (p, c) to set i if there's edge(u, i, c)
or edge(i, u, c). After that for each query, it simply asks the size of the intersection of set(u) and set(v), we iterate the 
set with a smaller size to answer the queries. https://codeforces.com/contest/506/problem/D

180. Desk Disorder (diff=2100, union find)
There are only 3 types of connected components, tp1: connected components that forms a functional graph, tp2: connected components
that forms a tree, tp3: connected components with self cycle. For case 1, the ans sould be doubled, case 2, ans could time the number
of vertices in such connected component. Since every vertex has at most 1 outlink, union find can help to detect cycle and self cycle
in this situation. https://codeforces.com/problemset/problem/859/E

181. New Roads (diff=2100, tree and observation)
The problem asks to construct a tree satisfies the ith level consists a[i] nodes and there are k leaf nodes. The key observation is
for every level from 0 to t-1, there must be at least 1 non leaf node and if a[i] > a[i+1], level i must have at least a[i] - a[i+1]
leaf nodes. We can mark the nodes that must be leaf node first and then link the edges. https://codeforces.com/problemset/problem/746/G

182. Place Your Ad Here (diff=2500, line sweep, range tree, set)
The problem asks to compute the largest cost[j] * intersection(interval of type 1, interval of type 2). We can easily classify it as
a line sweep problem. We should do 3 line sweeps in total. The first sweep, we eliminate all the channels that can be fully overlapped
by the videos using a set and update the answer. The second line sweep, we sort all the channels and videos by the r value and
use a range tree to update the answer. Finally, we sort all the channels and videos by the l value and use a range tree to update the
answer. https://codeforces.com/contest/542/problem/A

183. Breaking Good (diff=2200, BFS and dijkstra)
The problem is equivalent to finding the shortest path that has the most amount of 1 edge (i.e. shortest path that has the least amount of 0 edge). We can run 2 BFS first, one from vertex 1, the other from vertex n. Then, we construct a shortest path level graph with k[i] as weights. Finally, we run dijkstra's algorithm to find the shortest weighted path from 1 to n in the level graph we created in the previous step. https://codeforces.com/contest/507/problem/E

184. Information Graph (diff=2400, offline union find)
This problem is very similar to one of Ray's assignment problem. Asking whether x has a type i document is equivalent to asking,
whether at the time document i is signed whether x is the parent of y (the person that initially signed the document). This can
be done efficiently by sorting the queries according to the type-2 event. And then we do a line sweep, for each type-1 event, we union
point x and point y, for each type-3 event we simply see whether x and y is in the same connected component and y is in the subtree
of x. https://codeforces.com/contest/466/problem/E

185. Almost Acyclic Graph (diff=2200, dfs)
This examines the definition of backedge in dfs traversal. https://codeforces.com/contest/915/problem/D

186. Andrew and Taxi (diff=2200, binary search for final answer and top-sort)
The problem is actually asking select the minimum C, such that we only need to select edges with weight less than or equal to C
and reverse some in order to eliminate all the cycles in the graph. We can binary search on this C. However, how to validate the
final answer is quite tricky. Something we might ignore is if we do a top sort on an acyalic graph, if we keep adding edges from
some v1 to v2 which v1 has a top order less than v2, the graph would never contain a cycle. Hence, we can simply find the top
order of the subgraph formed with edges with weight greater than C, and add the remaining edges from a vertex with less top sort order 
to a vertex with greater top sort order. https://codeforces.com/problemset/problem/1100/E

* Feb 12 to Mar 11 --- "virus gap term training" focal point: dynamic programming, greedy and graph

187. Suggested Friends (diff=2200, graph connectivity and brute force)
If we cannot solve the problem if a smart way, the first thing we need to do is analyze the complexity of brute force. And we can see
if we just follow the definition of suggested friend we have a solution that is O(m^2) which m <= 5000, hence the brute force solution would run in time. https://codeforces.com/contest/245/problem/G

188. Tourism (diff=2200, tarjan's algorithm and simple tree dp)
The statement "not use any road twice in a row" should immediately remind us to use tarjan's bridge finding algorithm to compress
the biconnected components into a tree. However, there's something we have to be careful before run a simple tree dp to find the
largest weighted path from root to leaf. If a component size has size greater than 1 and one of its child has component size greater
than 1, one can actually walk down to the child and come back. Hence, in order to reduce the complexity of the dp procedure, 
if a biconnected component has size greater than 1, we recursively merge it to its parent. https://codeforces.com/problemset/problem/1220/E

189. Fishes (diff=2100, priority queue and expected value)
The answer is actually the sum of the k cells that has the largest total contribution. If we draw some examples we can figure out that
these k cells should group together, hence we can use a priority queue and a uninformed cost search that starts from (r, r) to 
find the k largest contributing cells. https://codeforces.com/problemset/problem/912/D

190. Roma and Poker (diff=2100, standard dp)
https://codeforces.com/contest/803/problem/E

191. Counter Attack (diff=2300, union find and range tree graph construction)
Similar to 653E, nothing special. https://codeforces.com/contest/190/problem/E

192. Tree Constructing (diff=2200, graph, construction)
There's an obvious observation, we can construct one diameter first and then add subtrees to the vertices on that diameter.
https://codeforces.com/contest/1003/problem/E

193. Iahub and Xors (diff=2500, 2d-fenwick tree)
I learned something new on 2d data structure :). https://vjudge.net/problem/CodeForces-341D

194. Anti-Palindromize (diff=2500, MCMF)
It is quite obvious that the problem is not a dp problem, so maxflow or MCMF should be our direction. The problem basically has
several constrains, for each letter is should be used exactly cnt_i times, for each position should match exactly 1 letter,
position i and position n-i+1 should have different letters. We can construct the following graph, connect src to nodes representing
a-z with cap= cnt_i, cost=0, create n/2 extra nodes for each letter (a-z), connect a-z to these extra nodes with cap=1, cost=0,
connect the extra nodes to i and n-i+1 (for all i) with cap=1, cost=-b[i] or 0 depending on whether the letter match with s[i] or not.
Finaly connect nodes 1 to n to the sink. Run MCMF would get the correct solution (print the the cost times -1).
https://vjudge.net/problem/CodeForces-884F

195. Evacuation (diff=2500, Dinic's algorithm)
It is obvious that this problem cannot be solved by greedy or dynamic programming, hence we try to construct a flow network. Let's firstly use BFS to compute the shortest distance from 'Z' to all cells. Then let's construct a level graph with t+2 levels. Connect
s to nodes in level 1 with capacity shown in the first grid. Connect level t + 2 nodes to t with capacity shown in the second grid.
Finally for nodes v1 in level i and v2 in level i+1, connect v1 to v2 iff v1 is adjacent to v2 and dist[v1] >= i and dist[v2] >= i.
Run maxflow would get the solution. The main lesson is for this type of very long problems, every sentence should be read carefully,
unless you want to get WA feedback. https://vjudge.net/problem/CodeForces-78E

196. Rectangle Painting 2 (diff=2500, Dinic's algorithm)
The key observation is we can do point compression on rows and columns seperately and partition the entire shape into several rectangle
regions. Then the problem is changed into the following, we can change all regions in some row/col with a given cost, what is the
minimum cost to change required cells black. This is a standard min-cut problem and can be solved by applying Dinic's algorithm.
https://vjudge.net/problem/CodeForces-1198E

197. Bipartite Segments (diff=2500, tarjan's algorithm, fenwick tree and line sweep)
The first observation is there's no nested cycle, so that after we use tarjan's biconnected component algorithm we can represent
each connected component as an interval [l, r], which l is the smallest vertex in that component and r is the largest index vertex
in that component. Then we establish 2 BITs to compute for each left end point i, what is the minimum r without a fully covered
interval. The problem is a quite standard line sweep problem and can be solved in O(nlogn) complexity. 
https://vjudge.net/problem/CodeForces-901C

198. Brackets (interval dp)
We define the sub problem(i, j) as the maximum matching by using brackets in the interval [i, j]. Then we can easily see that
we only need to consider where to partition the matching point. dp[i][j] = max(2match(i, j) + dp[i+1][j-1], dp[i][k] + dp[k+1][j], k=i..j-1) https://vjudge.net/problem/POJ-2955

199. Product Sum (diff=2500, convex-hull trick)
https://vjudge.net/problem/CodeForces-631E

200. Recursive Queries (diff=2500, line sweep and range tree lazy propagation)
The key observation is for each number its contribution is actually equal to qr - ql + 1, which qr refers to the right most position
such that the number is greater than all numbers between itself and qr, similar for ql. Hence, the problem is changed to a line 
sweep problem, we only need to calculate the total contribution of all numbers within the query range. We use range tree and lazy
propagation to solve this twice, once in the forward direction while another iteration in the backward direction.
https://vjudge.net/problem/CodeForces-1117G

201. Multiplication Puzzle (interval dp)
https://vjudge.net/problem/POJ-1651

202. B-number (digit dp)
https://vjudge.net/problem/HDU-3652

203. Bomb (digit dp)
https://vjudge.net/problem/HDU-3555

204. Blood Cousins (diff=2400, dfs and binary-lifting)
The obvious observation is this problem is equivalent to the following. Suppose that nv is the pth parent of v, we need to count
the number of nodes that is in the subtree of nv and has dist(nv, u)=p. For the find pth parent part, we can use binary lifting to do 
it. And for the counting part, we maintain a sorted vector for the dfs order of nodes of each level of the tree, and use binary search to find the left most and right most nodes that are in the same level of v and is in the subtree of nv. This solution works in
O(nlogn + mlogn) https://vjudge.net/problem/CodeForces-208E

205. Balanced Number (digit dp)
https://vjudge.net/problem/HDU-3709

206. AI robots (diff=2200, line sweep and dynamic range tree)
We use two pointers approach, pt1 points to the robot[i].x (in non-decreasing order), pt2 points to robot[i].x + robot[i].r (in
non-decreasing order). Then, before each time we query the total number of points between [robot[i].x - robot[i].r, x], we
delete all the points that its robot[j].x + robot[j].r cannot reach robot[i].x anymore. Using dynamic range tree is definitly
the best for this case, we simply maintain ~10^5 range trees, 1 for each IQ. https://vjudge.net/problem/CodeForces-1045G

207. Subtree Minimum Query (diff=2300, persistent range tree)
The solution is actually very simple, we establish persistent range trees according to the BFS order, and query the corresponding
tree according to the DFS order. https://vjudge.net/problem/CodeForces-893F

208. Mike and Feet (diff=2100, dp or binary search and sparse table)
The only thing I'm amazed with this problem is that I solved a standard dp problem with sparse table and binary search.
https://vjudge.net/problem/CodeForces-547B

209. The Bakery (diff=2200, dp, divide and conquer optimization)
The hardest part is how to calculate the cost(l, r), however, if we are familiar with Mo's algorithm i.e. always maintaing
the current valid window of cost, the problem is very easy to be solved in an amortized O(nklogn) complexity.
https://vjudge.net/problem/CodeForces-833B

210. Lucky Array (diff=2300, sqrt decomposition)
This problem has many solutions, we can either use sqrt decomposition or amortized range tree. https://vjudge.net/problem/CodeForces-121E

211. Quarrel (diff=2400, BFS)
The problem is actually very simple. let dist(i, j) refers to the shortest path to state i, j, then we use BFS to find the minimum
distance from state 1, n to state n, 1 without moving to any state (v, v) in the middle. https://vjudge.net/problem/CodeForces-29E

212. Salazar Slytherin's Locket (diff=2200, digit dp)
The observation is we only need to know how many times each digit occurs after the leading non-zero digit. We can use a bitmask
to represent the odd/even occurence of each digit 0-9. With memorization, we can easily get a complexity of O(q + 11*2^b*log(r)).
https://codeforces.com/problemset/problem/855/E

213. Two permutations (diff=2200, persistent range tree)
https://vjudge.net/problem/CodeForces-323C

214. Case of Fugitive (diff=2100, greedy and line sweep)
The problem can be solved by greedy should be figured out easily, however, how to do it correctly is not that stright forward.
We firstly sort all the gap according to a[i].r - a[i-1].l, and the bridges according to length. Then, we maintain a set of
bridges, which represents all the bridges that can be selected which length are no greater than a[i].r - a[i-1].l. Then, for
each gap we select the shortest bridge that is no less than a[i].l - a[i-1].r and remove the bridge from the set.
https://vjudge.net/problem/CodeForces-555B

215. DZY Loves Modification  (diff=2100, greedy)
Seperate rows and cols. https://vjudge.net/problem/CodeForces-446B

216. Pair of Numbers (diff=2100, math and binary search, sparse table)
The observation is actually very simple, we can validate if a[j] = gcd(l, r), and since as l decrease and r increase gcd(l, r) is
non-increasing, we can use binary search to get the optimal(l, r) for each j. Maintaining gcd(l, r) on a static array can be done
with sparse table. https://codeforces.com/problemset/problem/359/D

217. R2D2 and Droid Army (diff=2100, binary search and sparse table)
https://vjudge.net/problem/CodeForces-514D

218. Mishka and Interesting sum (diff=2100, line sweep and fenwick tree)
We process the queries offline, and always make sure for all numbers, we don't update its last occurrence in the BIT.
https://vjudge.net/problem/CodeForces-703D

219. Messenger Simulator (diff=2100, ordered statistic tree)
We introduce something called key, initially keys are equal to i. For each operation, we simply find the order of (key[v], v),
update max[v] and min[v] and then erase (key[v], v) from the ordered set. Finally, at the end of the operation, we add 
(minkey - 1, v) to the set. https://vjudge.net/problem/CodeForces-1288E

220. Same Sum Blocks (Hard) (diff=2200, data structures and greedy)
We can use prefix array to transform this porblem to a standard greedy problem. Select the maximum
amount of non-intersecting intervals from a group of intervals. https://vjudge.net/problem/CodeForces-1141F2

221. Clique Problem （diff=2100, dp and data structures）
The observation is, if we sort all the vertices according to x then if xj < xi and xi can connect to xj, then xi can connect
to all points in the clique which j has the largest x coordinate. Then, the rest of the problem is very simple after we rewrite the equation to xi - wi >= xj + wj. If we maintain a range max segment tree on xi+wi and process the points according to x increasing
order, then the problem is changed to a LIS problem, which can be solved easily in O(nlogn) time complexity.
https://vjudge.net/problem/CodeForces-527D

222. Tokitsukaze and Strange Rectangle  (diff=2200, line sweep and combinatory)
This problem is actually very hard. We need to know how to avoid double count for rectangles with the same y coordinate.
https://vjudge.net/problem/CodeForces-1190D

223. Multidimensional Queries (diff=2200, range tree and observation)
Since k <= 5, we can think how to solve this problem when k=1 or k=2. For k=1, we know that we can use divide and conquer range
tree to solve this problem, when we merge two intervals the answer is always lans, rans or lmax-rmin or rmax-lmin, we select
the maximum among those possible answers. Then, we might observe that for absolute values |a-b|, if we brute force all the cases
a > b or a <= b there are in total 1 << 5 cases which isn't too bad. And we also know the answer is the maximum among those
32 combinations. So the answer works as follows, we maintain range max, range min of (+-)b[l][1] (+-)b[l][2] (+-)b[l][3] .. (+-)b[l][k]
and use divide and conquer to merge them. Then final solution would work in O(160n + 32nlogn) which is fast enough.
https://vjudge.net/problem/CodeForces-1093G

224. Boredom (diff=2200, persistent range tree and combinatory)
https://vjudge.net/problem/CodeForces-853C

225. Arson In Berland Forest  (diff=2200, BFS and binary search on final answer)
There should be a health warning for this problem, it is absolutely a TLE giver.
https://vjudge.net/problem/CodeForces-1227E

226. Beard Graph (diff=2200, preparation for HLD)
https://vjudge.net/problem/CodeForces-165D

227. Drazil and Morning Exercise (diff=2800, persistent range tree, kruskal modification and tree dp)
We should immediately realize that q is only 50, which means that we can process the queries seperately. Firstly, let's do some 
precomputations, we preprocess the longest path (cost[i]) from every vertex i to a leaf using 2 dfs. Secondly, we use the kruskal modification algorithm, to produce a tree that satisfy for each node v every nodes u in its subtree has cost[u] >= cost[v].
Then the problem is changed to the following, we need to find the total number of nodes that's in the subtree of v which has cost
no greater than cost[v] + L. And we should realize that persistent range tree is perfect for this. 
https://codeforces.com/contest/516/problem/D

228. Round Subset (diff=2100, knapsack dp)
The observation is we can extract all the 2, 5 factor of a[1..n], then we define the subproblem as opt(i, j, k) be the maximum
number of factor 2 when select k numbers from the first i numbers with j fac 5. https://vjudge.net/problem/CodeForces-837D

229. Thwarting Demonstrations (diff=2200, fenwick tree and binary search for final answer)
This trick is too simple, just don't forget to push in 0 to the disc array when doing point compression. https://vjudge.net/problem/CodeForces-191E

230. A Heap of Heaps (diff=2200, persistent range tree and amortized complexity)
The problem is actually very easy to be solved. We note that only n/1 nodes in the first heap, n/2 nodes in the second heap and n/k valuable nodes in the kth heap which means that in total only O(nlogn) many nodes are useful query nodes. Hence, we can solve the 
problem with a smart brute force, for each valuable nodes we query the total number of nodes in a given range that has value less than
it. The query can be done in O(logn) if we use persistent range tree. Hence, the overall complexity is O(nlognlogn). 
https://vjudge.net/problem/CodeForces-538F

231. Duff in the Army (diff=2200, heavy-light decomposition)
We need to use heavy-light decomposition to decompose the tree in to ranges, and then we establish a range tree on sets to process
the queries. Overall complexity O(nlognlogn). https://vjudge.net/problem/CodeForces-587C

232. Smile House (diff=2300, binary lifting and matrices)
The problem is very nice. The first observation is we can binary search for the final answer, if the assumption that the smallest cycle
is less than v holds, any v' >= v would also holds. Hence, in order to compute v efficiently, we use the binary lifting trick. We
construct the shortest path matrices for 1-jump, 2-jump, 4 jump and so on. Then when we validate v, we can calculate matrix multiplication O(logv) many times. The total time complexity would be O(n^3lognlogn). https://vjudge.net/problem/CodeForces-147B

233. Getting Deals Done (diff=2300, greedy observation and binary search)
We should realize that the more task we solve, the more time we need. Hence, we can binary search for the final answer k and set d
to the kth smallest value of array p to validate each k. https://vjudge.net/problem/CodeForces-1070E

234. Company (diff=2300, range tree and LCA)
This is a tree observation problem. We can see that the LCA of a group of points in a tree is determined by the points with the minimum
and maximum dfsorder. Then the problem can be solved easily with the support of range min and range max range trees.
https://vjudge.net/problem/CodeForces-1062E

235. Happy Tree Party (diff=2300, heavy-light decomposition)
Almost HLD template problem, just be careful about the product overflow issue. https://vjudge.net/problem/CodeForces-593D

236. Cactus (diff=2400, tarjan's algorithm and heavy-light decomposition/LCA)
We could easily observe that for every simple cycle there are exactly 2 ways of getting from one point on the cycle to another point.
Hence, the problem is simply asking how many simple cycles are on the path from u to v. We can firstly use tarjan's algorithm
to extract all the biconnected components, and then for each query it is simply asking count the number of size > 1 components 
from u to v. It can be solved by LCA or heavy-light decomposition. https://vjudge.net/problem/CodeForces-231E


237. Construct a tree (diff=2300, binary search on final answer and graph construction)
We can binary search on the branching factor. Suppose we know that there exists an answer for branching_factor <= d, there must
exists an answer for branching_factor <= d + 1. After that we can greedily construct the tree (i.e. putting as mych nodes as
possible on the current level). https://vjudge.net/problem/CodeForces-1098C

238. Choosing Balls (diff=2200, observation and dp)
Only the top 2 colors are essential. https://vjudge.net/problem/CodeForces-264C

239. Anton and Permutation (diff=2300, sqrt decomposition)
We maintain O(sqrt(n)) many ordered vector for each sqrt range, and perform queries in O(qsqrt(n)logn) time and update in O(qsqrt(n))
time. https://vjudge.net/problem/CodeForces-785E

240. Voting (Hard Version) (diff=2300, greedy)
The observation is quite similar to "DZY Loves Modification". https://vjudge.net/problem/CodeForces-1251E2

241. Array and Segments (Hard version) (diff=2300, line sweep and range tree)
This is probably my worst performance problem of the month. Firstly, we can easily observe that we can iterate through all the i
to be the minimum of the resulting array, and apply all the updates that covers i completely. However, after that we should realize
the problem can be done efficiently by using line sweep, which I spent too long to do so.
https://vjudge.net/problem/CodeForces-1108E2

242. Printer (diff=2300, binary search on final answer and line sweep)
The problem is actually quite easy to come up with a O(n^2) solution. We know that only O(n) many priorities need to be checked.
A key observation is the lower the priority of task x, the later it would finish. Hence, we can binary search on the final answer!
After realizing this fact we search the minimum priority that satisfies the finishing time of task x is no later than T. The
problem would be reduced to a standard line sweep problem which can be solved with a priority queue.
https://vjudge.net/problem/CodeForces-253E

243. Marbles (diff=2200, bitmask dp and observation)
Let's firstly consider how to solve this problem by complete brute force. This is, we can brute force all the permutation of m (m=|{a[i]}|) and then assign each a[i] an element of the permutation, then we use divide and conquer algorithm to solve this problem. 
This approach works in O(m!n) which is too slow. Let's try to optimize the approach, we can firstly work out how many i occurs before j
for each pair of i, j and stores them in a 2-d array. Then, we let dp[state] represents the minimum number of inversion pairs to let all bits of state occupying the first bitcount(state) many chunks. Then the problem is a standard bitmask dp which can be done in
O(m^2*2^m + nm)

244. Three Pieces (diff=2200, dijkstra's algorithm/floyd-warshall algorithm)
Quite stright forward problem, just be careful with the level-graph construction. https://vjudge.net/problem/CodeForces-1065D

245. The Number Games (diff=2300, binary-lefting and amortized complexity)
Key observation if we can select number v (the largest remaining number), we should definitly take it, because of the property of
binary representations. Then, the problem is reduced to the following, we should query what's the total number of nodes on the path
from v to the nearest selected parent node and see if it is no greater than k, if so we brute force update all the nodes from v to
the parent node and decrease k. We should realize that the first type of operation can be done with binary-lifting because if a node
is updated all its ancestors should be updated as well. The second type of operation can be done with brute force in an amortized O(1)
complexity. Hence this solution works in O(nlogn). https://vjudge.net/problem/CodeForces-980E

246. Delete a Segment (diff=2300, line sweep)
My first observation was wrong. I tried to use union find to solve this problem. However, we should immediately realize that 
this is unfeasible because it is very hard to delete a range in union find data structure. Then I realized since we can only
delete 1 segment, after the deletion the number of connected component is going to increase at the point where this segment
is the only segment in that range [l, r] and there exists some segment [l',r'] and [l'',r''] such that l < r' and l'' < r.
We can use sweeping to figure out the increment value for each segment. One special case is, if the segment is disjoint to all
the other segment its removal cost should be -1. We should remove the segment with the largest removal cost and add that cost to
our initial answer. https://vjudge.net/problem/CodeForces-1285E

247. Blood Cousins Return (diff=2300, range tree and line sweep and binary-lifting)
We observe that the query corresponds to a concecutive BFS order interval. Hence, we can use binary search/binary lifting to figure
out the corresponding [l, r] bfs order of each query range in O(nlognlogn) time. Finally the problem is changed into the standard
line sweep and range tree problem, answer the number of distince elements in q [l, r] ranges which can be done in O(nlogn) time.
https://vjudge.net/problem/CodeForces-246E

248. Sum Queries? (diff=2300, obseration and range tree)
The key observation is something we might ignore, the optimal solution is definitly two smallest numbers with 1 digit all not equal to 0. After this is figured out, the problem would be a standard point update and range min query problem. https://codeforces.com/problemset/problem/1217/E

249. The Maximum Subtree (diff=2300, observation and tree dp)
If we draw enough examples, we can figure out the optimal solution is for each non-root node, it can attach 1 child with optimal structure and the remaining children. For the root is can attach 2 child with optimal structure and the remaining children. Since all nodes can be the root, we use 2 dfs to find the solution. https://vjudge.net/problem/CodeForces-1238F

250. Runner's Problem (diff=2300, line sweep and matrix)
For this kind of recursive formula, we can use matrix fast exponential algorithm to get the value of f(i, j) efficiently. For
the rest of the problem, we just need to know in the interval which matrix shall we use, which is a quite standard line sweep problem.
https://codeforces.com/contest/954/problem/F

251. Optimal Sum (diff=2300, line sweep and greedy)
The is a sliding window problem, we just need to maintain the k smallest negative numbers in a[i-len+1, i]. Make sure the invariant
of each function is clear. https://vjudge.net/problem/CodeForces-182C

252. Wormhouse （diff=2300, backtracking and pruning）
https://vjudge.net/problem/CodeForces-62D

253. Strip (diff=2300, sparse table and binary search and range tree, dp optimization)
https://vjudge.net/problem/CodeForces-487B

254. Buy Low Sell High (diff=2300, greedy observation)
We could observe the following fact about the stock trading. If we buy stock v1 and sell v3, it is equivalent to buy v1, sell v2, 
buy v2, sell v3. Hence, we can maintain a min heap and for every element if the heap is not empty, we check if the heap top is
less than the element, if so, we make a trasition and insert the element to the heap (this is very important because the element 
can still involve another trading). Otherwise, we insert the element to the heap.
https://vjudge.net/problem/CodeForces-865D

255. Sereja and Subsequences (diff=2300, dp and fenwick tree)
Let's define dp[i] as the number of valid subsequence that ends with number i. We can observe that dp[i] = i * (1 + sum(dp[j], j = 1..i-1) + delta) The hardest part is how to calculate this delta. Note that for a subsequence that ends with i, only subsequence ends with i and subsequence that ends with v < i can be the prefix of i. Hence delta should equal to the most recent version of dp[i].
Since we need to support point update and range sum query quickly, we can use a fenwick tree to speed up our dp procedure.
https://vjudge.net/problem/CodeForces-314C

256. Lomsat gelral (diff=2300, dsu on tree, merge from small to large)
The problem involves some very important technique. Let's solve the problem by a dfs traversal. For every node let's store
an unoredered_map<color, colorcnt>, a set<pair<colorcnt, color>> and ans and f (the node that actually representing this node).
Every time, when we are at a root node, we call merge(v, child[v]) for all u belongs to child[v]. What merge does is merge the smaller
unordered_map to the larger one and fix the f array. Initially we might think this is a O(n^2logn) approach. However, if we apply master theorem we can see the worst case of this approach is T(n) = kT(n/k) + O(nlogn) which is O(nlognlogn).
https://vjudge.net/problem/CodeForces-600E

257. Dominant Indices (diff=2300, dsu on tree, merge from small to large)
Almost the same as the previous problem. Just remember the map should be <depth, depthcnt> instead of <dist, distcnt>.
https://vjudge.net/problem/CodeForces-1009F

258. Tree Requests (diff=2400, binary search and bitmask)
If we solve this problem using a brute force way, we can achieve a time complexity of O(26 * mlogn). The approach is we establish
a level graph which stores the dfs order of nodes of each level for each letter. Then, when we process a query, we just use binary
search to find the L, R position of nodes on the level h which is in the subtree v. In order to make a string palindrome, there's
at most 1 letter occurs odd number of times, hence we can use the prefix sum array to maintain the occurence of letters. However, 
this approach would run only 20ms faster than the TL, any bad implementation would make it TLE. Since we only need to know the odd/
even occurence of letters a-z, instead of storing the occurence, we store the bitmask and use xor/countbits to maintain the queries.
This would wipe out the constant factor 26. https://vjudge.net/problem/CodeForces-570D

259. Mahmoud and a xor trip (diff=2200, tree dp and bit operation)
Let's represent value[v][i] as the cumulative xor sum of the ith bit from root to v. Then the ith bit of node v, u would contribute
to answer iff value[v][i] ^ value[u][i] ^ value[LCA(u, v)][i] ^ value[pre[LCA(u, v)]][i] = 1. Hence, we can use tree dp to solve this
problem, firstly count the number of 1 bit and 0 bit in the subtrees and use the above conditions to merge the results.
https://vjudge.net/problem/CodeForces-766E

260. Random Task (diff=2200, binary search and digit dp)
We can think what would happen if n is increased to n+1, we should consider how the bitcount change from [n+1, 2n] to [n+2, 2n+2].
We realize that n+1 has the same number of bits as 2n+2, hence the total number of bit k numbers is none decreasing if we increase n.
Therefore, we can binary search on the final answer and use digit dp to validate the solution.
https://vjudge.net/problem/CodeForces-431D


261. Igloo Skyscraper (diff=2400, range tree and CHT)
We know that convex-hull trick could deal with the dominate line at an x-coordinate query in O(logn) time and range tree could support
range queries. We should combine these two together. The solution works as follows, we sort the lines according to gradient and break the tie by the y-intersect. We maintain a range tree of CHT data structure and then insert the lines to all ranges that covers it (total O(logn)). When we query, we just call the query function of the CHT of the corresponding ranges. The solution works in O(nlognlogn). https://vjudge.net/problem/CodeForces-91E

262. Okabe and El Psy Kongroo (diff=2200, dp and matrix fast multiplication)
https://vjudge.net/problem/CodeForces-821E

263. TV Game (diff=2200, dp)
The only trick here is solve this problem backward. Instead of appending the numbers at the back, consider the string in a backward
direction and append the numbers to the front. https://vjudge.net/problem/CodeForces-31E

264. Skills (diff=2200, greedy and binary search)
The key observation is we can iterate on how many full-skill we are going to choose and if this number is equal to k, we should choose
the k largest skills. Then, we should use our remaining coins on maximizing the minimum skills which can be solved by using binary
search on final answer. https://vjudge.net/problem/CodeForces-613B

265. The Doctor Meets Vader (Medium) (diff=2300, Dinic's algorithm)
Firstly, I think this is a MCMF problem. But the time complexity might be too high. Note that there's only 2 costs. We can firstly
run Dinic's algorithm to find the largest bipartite matching of the graph. And then if we have the math observation, we should know
that the answer is either k times flow or h times b. (Lesson we learned, Dinic's algorithm is |V|^(5/2) on complete bipartite graph,
we shouldn't worry for |V| is up to 1000)
https://vjudge.net/problem/CodeForces-1184B2

266. Machine Programming (diff=2400, MCMF)
Learned a lot from this problem. It is obvious that the problem can be solved using MCMF. However, the graph construction isn't that
easy. We firstly get a unique vector of time (both s[i] and s[i] + t[i]) in sorted order. And connect the adjacent time with an edge
of cost 0, capacity k. This means that at any time there's at most k machine working. Then, we connect the vertex corresponds to
s[i] and s[i] + t[i] with an edge of capacity 1 and cost c[i]. After that we'll run MCMF and get the solution. 
https://codeforces.com/problemset/problem/164/C

267. Inna and Sequence (diff=2300, range tree and searching)
Delete a nonconsecutive segment is something that cannot be done with range trees. However, we might notice that there's only n operations. Which means that there's at most n numbers. We can establish a range tree and support delete the kth element, insert at
the back. When we deal with a deletion query we just delete a_i one by one, and this would achieved an amortized O(nlogn) complexity.
https://vjudge.net/problem/CodeForces-374D

268. Ann and Books (diff=2500, Mo's algorithm)
The problem simply asks to count the number of pairs such that the prefix sum differs by k. Counting the number of v in a range is 
usually undoable by range trees/fenwick trees. Hence, we use Mo's algorithm to solve the problem. We maintain a cnt hash map which
counts the number of occurence of each prefix, and the rest of the problem is routine Mo's insert and deletion. The overall complexity
of the solution is O(qsqrt(n)). https://codeforces.com/problemset/problem/877/F


269. Vasiliy's Multiset (diff=1800, Trie template)
This problem can test whether your trie template is correct.
https://vjudge.net/problem/CodeForces-706D

270. Kuro and GCD and XOR and SUM  (diff=2200, Trie and amortized complexity)
We should create 1e5 many tries. For a insertion query, we insert u to all tries with id | u. Then for the type-2 query, we just
need to search in the trie[ki] for the v that would produce the largest v ^ xi and xi + v <= si. Since n/1 + n/2 + ... + n/n = O(nlogn)
The overall complexity of the solution works in O(nlognlogn). https://vjudge.net/problem/CodeForces-979D

271. Anniversary (diff=2100, fibonacci property and math)
I actually know the key property of this problem. Fib(gcd(a, b)) = gcd(Fib(a), Fib(b)). But I got stuck on finding out
the maximum number that satisfy the property r/x - (l-1)/x >= k. The key observation here is the total amount of value n/i can have
is O(sqrt(n)), hence, we can iterate x=1..sqrt(r) and select the maximum r/i or i that satisfy the above equation.
https://codeforces.com/problemset/problem/226/C

272. Addition Robot (diff=2200, range tree and matrix)
Just be really careful on lazy propagation and range merge. Don't forget that matrix multiplication is not commutitive.
https://codeforces.com/problemset/problem/1252/K

273. Permutation Separation (diff=2200, range tree and line sweep)
Firstly, let's think how to solve this problem with a polynomial algorithm. We can immediately have an O(n^3) solution.
The solution works as follows, we brute force all the cost(i, j), which cost(i, j) means the splitting index is i,
which j is the maximum number in the left partition. Then, we might observe that we can sweep from 1-n and use a
range tree to maintain the cost when i is the maximum number in the left partition. 
https://vjudge.net/problem/CodeForces-1295E

274. Castle Defense (diff=2100, binary search and line sweep)
The problem seems routine after solving many other harder problems. 
https://vjudge.net/problem/CodeForces-954G

275. Tourist (diff=2400, DP and range tree optimization)
The problem might seems very hard. However, we must observe that position j can go to position i iff
|xi - xj| <= V * (ti - tj) which implies xi - V*ti <= xj - V * tj and xi + V*ti >= xj + V * tj.
Hence, the problem is reduced to a LIS problem. We can sort according to xi + V * ti then V * ti - xi.
Maintain a range tree on xi - V * ti. After than the problem is a routine range tree point update and
range max query problem. https://vjudge.net/problem/CodeForces-76F

* Mar 12 to Apr 11 --- "virus gap term training 2" focal point: dynamic programming, greedy and graph

276. Palindrome Degree (diff=2200, rolling hash)
https://vjudge.net/problem/CodeForces-7D

277. MUH and Cube Walls (diff=2000, KMP)
We firstly build a new array A(2e9)B. Which A[i] = b[i+1] - b[i], B[i] = a[i+1] - a[i]. Then just run the 
finding failure array function of the KMP algorithm and the number of nxt[i] = w-1 would be the final solution.
https://vjudge.net/problem/CodeForces-471D

278. Till I Collapse (diff=2600, persistent range tree and complexity analysis)
Let's think what would happen if we solve this problem using a smarter brute force. We let k iterate from 1 to n,
and solve the problem for each k. We firstly use a persistent range tree that would maintain the number of distinct
number from [l, r]. Then, for each k, we let i iterate from 1 to n, and i always jump to the leftmost point such
that query[i, inext] > k. The solution seems to work in O(n^2logn). However, we should note the following fact,
if query[i, inext] > k, inext - i >= k. Hence, for every k the number of calls to query function is at most n/k times.
Which means the overall complexity of the algorithm would work in logn(n + n/2 + n/3 + ...) = O(nlognlogn) which would
definitely run in TL. https://vjudge.net/problem/CodeForces-786C

279. 80-th Level Archeology (diff=2200, observation)
Since <= has trasitivity, the problem is equivalent to figure out the valid range that could make a[i] < a[i+1] and get the
intersection of these ranges. We can observe that for each i and i+1, there's at most 2 non-intersecting ranges that could make
a[i] < a[i+1]. Hence, we can use the prefix array to maintain this range addition operation. Note that Fenwick tree/range tree is
overkill here, since the query is after the update. https://vjudge.net/problem/CodeForces-731D

280. Ciel and Gondolas (diff=2600, dp and divide and conquer optimization)
https://codeforces.com/problemset/problem/321/E

281. Berland and the Shortest Paths (diff=2400, shortest path tree and backtracking)
The problem can be splited into 2 parts, firstly construct the shortest path dag using BFS, secondly
find combinations of the n-1 edges that can form a shortest path tree. The first part is quite standard.
The obstacle is how to do the second part correctly. We notice that except the root node, every node has
at least 1 parent, instead of doing the dfs from root to leaf and use backtracking, we can do the dfs from 2-n,
and use backtracking on the selected edges. https://vjudge.net/problem/CodeForces-1005F

282. Dish Shopping (diff=2800, line sweep and fenwick tree and ordered statistic tree)
This problem is doable, but I failed to solve it. The main obstacle is the sweeping order and the nested data structure.
https://vjudge.net/problem/CodeForces-1139F

283. Perfect Service (tree dp)
https://vjudge.net/problem/UVA-1218

284. DZY Loves Fibonacci Numbers (diff=2600, range tree, lazy propagation and fibonacci property)
We need to use F[n] = fib[n-1] * F[2] + F[1] * fib[n-2] and S[n] = F[n+2] - F[2] to solve this problem.
https://vjudge.net/problem/CodeForces-446C

285. Bipartite Checking (diff=2600, dynamic union-find, range tree on queries)
This is covered in Ray's assignment. https://vjudge.net/problem/CodeForces-813F

286. Mokia (CDQ divide and conquer)
https://vjudge.net/problem/HYSBZ-1176

287. Intersection of Permutations (diff=2300, CDQ divide and conquer)
The size of the intersection is equal to the number of points in the rectangle (x1,y1,x2,y2). If we express it more precisely,
it is (x1, y1, t, x2, y2, t). Which is a standard 3-dimensional partial order problem which can be solved by using CDQ divide and conquer.
https://vjudge.net/problem/CodeForces-1093E

288. Goodbye Souvenir (diff=2800, CDQ divide and conquer, line sweep observation)
Firstly let's think how to solve this problem if no update involved. We can use the standard line sweep technique.
We sort all the queries according to r, and do a line sweep, each time we update the previous occurence of the number.
We can use a fenwick tree to support this in O(nlogn) time. Now let's consider updates. It is like we do an update at time t,
and do a query at time t'. Hence another dimention involved, the problem is changed to a 3 dimensional partial order problem,
which can be done by using CDQ divide and conquer. https://vjudge.net/problem/CodeForces-848C

289. Heroes of Making Magic III (diff=2700, range tree and math observation)
The explaination is in the code. https://vjudge.net/problem/CodeForces-717F

290. Nearest Leaf (diff=2600, range tree and line sweep, dfs)
Initially I think this problem is undoable. Suddenly, I realized there's a reduced version of this problem which is much simpler.
Find the shortest distance from v (for every 1 to n) to any of the leaf. Which is a standard 2-time dfs problem. This problem
just add restrictions on the range of nodes that can be selected. Firstly, we preprocess the depth of the nodes and establish a
range tree of it (depth of non-leaf nodes are set to INF). Then, we do a second dfs, suppose nv is one of the child of v. We update
[1, nv-1] [nv+sz[nv], n] by weight(v, nv) and [nv, nv+sz[nv]-1] by -weight(v, nv). Every time we reach a node v, we answer all the 
range queries related to v. https://vjudge.net/problem/CodeForces-1110F

291. Building Forest (diff=2200, union find)
This problem is actually the template of CF813F. https://vjudge.net/problem/CodeForces-195E

292. Konrad and Company Evaluation (diff=2300, graph and complexity analysis)
The observation is the number of triple is equal to sum of out[i] * in[i] for all i from 1 to n.
https://vjudge.net/problem/CodeForces-1210D

293. Looksery Party (diff=2300, graph construction)
The most important sentence in the problem is every i would send a message to itself, think why. This would eliminate all -1 case!
https://vjudge.net/problem/CodeForces-549B

294. Leha and another game about graph (diff=2100, graph construction)
We could shown that the graph has solution is equivalent to its spanning tree has solution.
https://codeforces.com/contest/841/problem/D

295. Chemistry in Berland (diff=2400, dfs)
The only difficulty about this problem is the number might overflow, but we should realize if the required amount is less than 1e17,
then it is impossible to make the chemical reaction happen. https://vjudge.net/problem/CodeForces-846E

296. One-Way Reform (diff=2300, Hierholzer's algorithm, Euler tour, observation)
The very important observation is if the graph consists an Euler tour all nodes can satisfy the in=out condition.
https://vjudge.net/problem/CodeForces-723E

297. Array and Operations (diff=2400, Dinic's algorithm)
It can be seen easily that this is a matching problem. We split according to odd and even indices and for each number we do prime
factorization and connect the common prime for each good pairs with INF capacity. https://vjudge.net/problem/CodeForces-498C

298. President and Roads (diff=2600, dijkstra's algorithm and tarjan's bridge finding algorithm)
The solution is very simple, we run dijkstra's algorithm twice and see if an edge is on the shortest path. Then, we construct 
the shortest path (undirected) dag and find the bridges in that dag. Finally, when we do classification of edges, we return "YES",
only if the edge is on the shortest path dag and is a bridge. Be really careful about the parrallel edges case.
https://vjudge.net/problem/CodeForces-567E

299. Graph Coloring (diff=2300, dfs)
We should analyse how to make all edges red. It is for each red edge we either switch both of its endpoints or none and for each blue
edge we switch one of its endpoint. This would reduce the problem to a dfs coloring problem and can be solved in O(n+m) time.
https://vjudge.net/problem/CodeForces-662B

300. Cactusophobia (diff=2300, Dinic's algorithm and tarjan vertex biconnected component)
I would review this problem once in a while, because it is so nice. https://codeforces.com/contest/720/problem/B

301. Underfail (diff=2400, MCMF)
The problem is very similar to problem164C machine programming the graph construction procedure is almost the same.
https://codeforces.com/problemset/problem/717/G

302. Deciphering (diff=2400, MCMF)
The can calaulate how many match(a, b) (i.e. a in the first string match b in the second string), match(a, c)... match(Y, Z) for all k*k pairs.
Then the problem would be turned into a MCMF problem and can be solved easily. https://vjudge.net/problem/CodeForces-491C

303. Privatization of Roads in Berland (diff=2600, Dinic's algorithm)
The explaination is in my code. Learned something from Ray. https://vjudge.net/problem/CodeForces-1070I

304. Road Construction (diff=2600, Dinic's algorithm and tarjan's bridge finding algorithm)
Since the graph is a functional graph, we can only remove at most 1 cycle edge. Hence, we can firstly run the tarjan's bridge finding
algorithm and then the problem would be turned into a matching problem. https://vjudge.net/problem/CodeForces-1252L

305.  Electric Scheme (diff=2600, Dinic's algorithm and data structures, observation)
We can think this problem as merge horizontal/vertical intervals together without producing any extra intersection points. Then we could
transform the problem into a project selection type min-cut problem. We create a bipartite graph, put all horizontal segments on the left,
vertical segments on the right. Then, for every edge we cut means we force to abandon that merge. For each invalid intersection of horizontal
and vertical segments we connect an edge with INF capacity. Then the final answer would be the complement of the segments in the min-cut.
To make our life easier, we can use some data structures to solve this. https://codeforces.com/problemset/problem/1054/F

306. Gang Up (diff=2600, MCMF)
The technique to construct x^2 cost is similar to a 2300-MCMF problem. It is connect x edges which are 1,3,5,7,... And the technique to model
graph traversal is similar to problem 78E, which is construct a 100-level graph. Combining those 2 techniques would give a MCMF solution.
https://vjudge.net/problem/CodeForces-1187G

307. Black and White Tree (diff=2200, graph construction)
The key observation here is for the edge connects a leaf node and its parent, the edge must have a weight equal
to the leaf node weight. Hence, we can create this tree greedily in a bottom up approach.
https://vjudge.net/problem/CodeForces-260D

308. Privatization of Roads in Treeland (diff=2500, graph construction)
Solve this problem greedily. https://vjudge.net/problem/CodeForces-1141G

309. Road Problem (diff=2600, tarjan's biconnected component, construction)
This problem is equivalent to add the minimum amount of edges to make the graph into one biconnected component. The approach is very
simple, firstly find all the biconnected components and compress the points to make the graph into a tree. Then, we should connect
the leaves pairwise (the order is very important, according to dfs order 1->ans/2, 2->ans/2+1 etc.).
https://vjudge.net/problem/CodeForces-45H

310. Make k Equal (diff=2400, observation)
First observation, the final element should be an element in the array. Hence, we can sort and calculate the cost of making at least k
elements equal to a[i]. https://codeforces.com/problemset/problem/1328/F

311. Cheap Robot (diff=2600, kruskal modification and dijkstra, observation)
The first observation I had when solving this problem is if we define w(i, j) as the shortest distance between i and j, then by the
property of Kruskal minimum spanning tree, the kruskal tree formed by the k special nodes with w(i, j) as edge weight is the tree
that would describe the answer. When we query i, j we simply return the node value of LCA(i, j). However, how can we build the kruskal
tree efficiently. The key observation here is we can replace our initial edge weight with dist[i] + w + dist[j], where dist[i] is the
shortest distance of the ith node to any of the k special nodes. Then, we can just build the kruskal tree based on the new weights.
The reason for this to work is because if we want to go accross an edge, we have to be safe to move like special_node ->... u->v->special_node.
Then if two special node has shortest distance greater than dist[i] + w + dist[j], this edge cannot be used. 
https://vjudge.net/problem/CodeForces-1253F

312. Vladik and Entertaining Flags (diff=2600, union find, range tree and divide and conquer)
Since this is a range query problem, we should directly think the use of range trees. We should consider what would happen if we merge
2 connected connected components together. Only the cells on the boarder can affect the result.
https://vjudge.net/problem/CodeForces-811E

313. Matching vs Independent Set (diff=2200, observation)
The observation is we can greedily select the matching, if there's no n matching in the graph, then the remaining
vertices must form an independent set. Think why :). https://vjudge.net/problem/CodeForces-1198C

314. Trails and Glades (diff=2400, construction)
This is definitely not a hard problem, but it is something we might get wrong. The main WA point is 1 might be an isolation vertex.
https://codeforces.com/problemset/problem/209/C

315. Weird Advertisement (line sweep)
This is a modification of the union of rectangle area. https://vjudge.net/problem/UVA-11983

316. Dima and Trap Graph (diff=2400, union find and line sweep)
The observation is very similar to problem 377D, we are actually looking for a [l, r] bound that would satisfy
if we union all the edges that covers [l, r] 1 and n are in the same connected component. After finding out
this part the problem is reduced to a line sweep and union find problem.
https://vjudge.net/problem/CodeForces-366D

317. Gift (diff=2300, kruskal)
The observation is as follows once an edge is eliminated from the MST, it should never be considered again.
Since n is only 200, we can maintain a sorted vector of size at most 200 that contains all the candidate edges
so far. We iterate g in increasing order and create the MST of b. 
https://vjudge.net/problem/CodeForces-76A

318. Prefix Enlightenment (diff=2400, observation and union find)
The key observation here is the k subsets form a bipartite graph. For any position at most 2 subset determines
its status. Hence, the problem is reduced to the following, there are 3 types of queries and every time report
the minimum possible size of the LHS of the bipartite graph. 1. join a and b 2. claim a and b are in different
part of the graph 3. claim a is not in LHS of the graph. This can be done efficiently by using union find.
The detailed of the trick is similar to a problem in NOIP 2010. 
https://vjudge.net/problem/CodeForces-1291E

319. April Fools' Problem (medium) (diff=2500, MCMF)
The way to model order of events should be covered by many other MCMF problems. This problem is actually asking
the min-cost flow with the flow exactly k. https://vjudge.net/problem/CodeForces-802N

320. Dividing Kingdom II (diff=2500, union find)
This problem is also similar to the problem in NOIP 2010, check bipartite of a graph using union find.
I'll make up the qnlogn solution later, qm works though. https://vjudge.net/problem/CodeForces-687D

321. Yet Another Maxflow Problem (diff=2700, observation, line sweep and range tree)
We know that the maxflow of a graph is equal to the min cut. The key observation here is for each cut, it is
cutting an A_A edge, a B_B edge and all the A_B edges that pass through the cut. Another observation is the
update for each i wouldn't affect the selection of B_B edge in that cut. Hence, we can process for each A_i cut
on the LHS what's the optimal value of the B_j cut on the RHS, and this can be done with range tree and line sweep.
Then with each update the problem is changed to a range query and point update problem which can also be done
with range trees. https://vjudge.net/problem/CodeForces-903G

322. Power Tree (diff=2600, range tree and observation)
After drawing many examples on paper, I successfully reduced the problem to on changing tree. Then it can be solved
by using range tree and lazy propagation. https://vjudge.net/problem/CodeForces-607D

323. Watching Fireworks is Fun (diff=2400, dp and monotonic queue)
The dp state is very simple, since n and m has a product of order 1e7, we should immediately come up with a 2-d
dp equation. Then, the problem is reduced to maintain a range min in a range of fixed length. Which can be
done with a monotonic queue. Note that using range tree/sparse table here is overkill. 
https://vjudge.net/problem/CodeForces-372C

324. Bear and Fair Set  (diff=2500, Dinic's algorithm observation)
The exactly k element condition is very easy to model, just build a flow graph and see if those edges are in there
full capacity. https://vjudge.net/problem/CodeForces-628F

325. Appleman and a Sheet of Paper (diff=2500, fenwick tree, implementation)
We know that for each fold the paper size would be reduced by the number of updates we make. Hence, the complexity
would be an amortized O(nlogn). Then, we should realize a tricky part of the problem, when 2 * pos > len we cannot
do the same thing as 2 * pos <= len. To counter this, we can introduce a tag, when tag is 1, we should update
from right to left otherwise, we update from left to right. Every time a 2 * pos > len occurs, we invert our tag.
https://vjudge.net/problem/CodeForces-461C

326. Serge and Dining Room (diff=2400, observation, range tree)
The problem is very hard to observe the key property. For a group of people, if they change the order of the
purchase procedurem the final set of dish wouldn't be changed. After this is figured out, the answer would
be the largest x such that the number of dish with cost >= x is larger than the number of pupils with money >=x.
This can be done with range tree and lazy propagation. 
https://vjudge.net/problem/CodeForces-1179C

327. Boxes And Balls (diff=2300, greedy)
Working in reverse order. https://vjudge.net/problem/CodeForces-884D

328. Ralph And His Tour in Binary Country (diff=2300, implementation and binary search)
We should make good use of the heap, since each path length is at most logn many nodes, we can maintain logn
levels of sorted vectors and support get the number of elements smaller than k. Overall complexity O(nlogn + mlogn^2)
https://vjudge.net/problem/CodeForces-894D

329. Minimal Segment Cover (diff=2200, binary lifting)
We can see what's the furthest point that can be reached when using 1 << j many intervals. Then the problem
can be solved easily by using line sweep and binary lifting. What's even more important is this problem
is the first case of NN countery, a 2700 data structure problem. https://vjudge.net/problem/CodeForces-1175E

330. Ray in the tube (diff=2400, observation)
If we have some physics knowledge, we should know that only log(1e9) many steps should be considered. Also don't
forget about to consider the edge case when the Ray emits in an upright direction.
https://vjudge.net/problem/CodeForces-1041F

331. Half-decay tree (diff=2400, observation)
The most important thing is the height of the tree is O(logn), hence we should think how each update can affect the answer.
We should realize that the update can only affact answer of log(n) many regions of leaves.
https://vjudge.net/problem/CodeForces-68D

332. Area (pick's theorem)
https://vjudge.net/problem/POJ-1265

333. LIS of Sequence (diff=2400, dp and observation)
https://vjudge.net/problem/CodeForces-486E

334. Split the Tree (diff=2400, greedy and HLD)
The important observation is, for every leaf if we extend that path to the furthest point it can reach, the
solution is optimal. Then the problem is reduced to a standard HLD problem. We just need to iterate backward,
and for each unvisited node, we set the entire path from it to the furthest point to 1.
https://vjudge.net/problem/CodeForces-1059E

335. Lining Up (line point template)
https://vjudge.net/problem/POJ-1118

336. Map (diff=2500, line sweep and monotonic queue)
The main issue is finding the minimum element for every submatrix of size (a,b). This can be done efficiently
by running the algorithm for 1d static range min of fixed length twice. https://vjudge.net/problem/CodeForces-15D

337. Ancient Berland Circus (diff=2100, sine law and cosine law)
https://vjudge.net/problem/CodeForces-1C

338. Pyramids (diff=2100, sine law)
https://vjudge.net/problem/CodeForces-630Q

339. Harry Potter and the Golden Snitch (diff=2100, binary search and similar triangle)
https://vjudge.net/problem/CodeForces-65C

340. Area of a Star (diff=2400, sine law)
Be careful about the precision issue, use acos(-1.0) to represent Pi!. https://vjudge.net/problem/CodeForces-630P

341. Tricky Function (diff=2100, geometry, divide and conquer)
This is a standard nearest pair in a 2d plane. https://vjudge.net/problem/CodeForces-429D

342. Rooter's Song (diff=2100, geometry, observation)
We can see that collision happens only if two points are on the same y=-x+b line after considering the time
offset. After that, we should observe that for each group, a point is actually moving in a z-shape.
https://vjudge.net/problem/CodeForces-848B

343. Count The Rectangles (diff=2200, geometry, line sweep)
Let's think how to solve this problem using O(n^3) brute force, it is we enumerate all pairs of horizontal 
intervals and check how many vertical segments intersect with both, then add C(num, 2) to the answer.
Then, we can try to optimize this approach, we should add in all the vertical segments that intersects with
one of the horizontal segment, and then before each query, we delete all the vertical segments that has a
upper point lower than the second horizontal segments. The number query is a range sum query which can be
done by using a fenwick tree. The complexity of the solution is O(n^2logn) which fits the time limit.
https://vjudge.net/problem/CodeForces-1194E

344. Points on Plane (diff=2300, geometry, sqrt decomposition observation)
We should think what's special about 2500000000, it is larget than 2 times 1e9. Note that if we seperate the
entire plane into 1e6 many 1e3 by 1e3 blocks, and for each block we sort those points according to y coordinate.
Then connect the points in a z-shape, the path length would never exceed the required length.
https://vjudge.net/problem/CodeForces-576C

345. Mice problem (diff=2200, geometry, implementation)
We should realize that the problem is actually asking the left bound of 
the intersection of some valid time intervals. https://vjudge.net/problem/CodeForces-793C

346. Nature Reserve (diff=2200, geometry, binary search for final answer)
We should know that if a circle of size r1 can cover all the points, a circle of size r2 > r1 can definitly
cover all the points as well. Hence, we can binary search for the final answer and check whether there's a valid
x for putting the circle on the x-axis. https://vjudge.net/problem/CodeForces-1059D

347. Rest In The Shades (diff=2400, binary search, geometry)
If we have some physics experience before, we should know that this problem is equivalent to finding the
total projection length from a query point to the given interval. Then we should realize only a range [l, r]
would contribute to the answer, and the projection length can be calculated using similar triangles.
https://vjudge.net/problem/CodeForces-1016E

348. Timofey and rectangles (diff=2200, four-color theorem)
The key lesson here is read the problem statement clearly, think what's important about the length of the edge
is odd. This means that we can seperate the space into 4 parts according to lower left vertex.
https://vjudge.net/problem/CodeForces-763B

349. Restore Cube (diff=2200, brute force)
We should observe that if we brute force all the combination of permutations there's only 6^7 many cases which
would definitly fit the time limit. Then, given 8 points judging whether it forms a cube can be done by counting
the number of 1, sqrt2, sqrt3 edges. https://vjudge.net/problem/CodeForces-464B

350. Transmitters (cross product on angle calculation)
https://vjudge.net/problem/UVALive-2290

* Apr 12 to May 11 --- "virus gap term training 3" focal point: all except dynamic programming

351. Nearest vectors (diff=2200, angle sort)
https://vjudge.net/problem/CodeForces-598C

352. Vasya and Maximum Profit (diff=2400, line sweep and range tree, monotonic stack)
The hardest part is how to deal with the d^2, we can see that each d^2 controls a range, we can use monotonic
increasing stack to maintain a decreasing d^2 and then the problem is changed to a line sweep and range min 
query problem. https://vjudge.net/problem/CodeForces-1107G

353. Case of Computer Network (diff=2800, LCA, tarjan's algorithm, HLD)
We can compress the graph into a tree by running tarjan's algorithm. Then, for each path in the compressed
tree, let's denote the down to up path by -1 and up to down path by 1, then we can use HLD to maintain a
range min segment tree and check whether there's any contradiction.
https://vjudge.net/problem/CodeForces-555E

354. Maximum Waterfall (diff=2500, line sweep and dp)
We should realize the dominate relationship form a DAG. Then, we should use line sweep on the right endpoint, 
not height!!! to build the DAG and run a simple dp to get the solution. https://vjudge.net/problem/CodeForces-269D

355. Choosing Subtree is Fun (diff=2600, HLD, LCA, binary-lifting, line sweep, observation)
The first obseration is if we consider each r, l can only increasing. Hence, we should maintain a dynamic data
structure that records how many nodes are in the connected component [l, r]. We should observe that when we add 
i to the structure, we are actually set the path from i-1 to i to 1. Then if the total node weight in our HLD
structure exceeds k, we should remove l and increment l by 1. Then, the second obstacle of this problem comes,
how can we remove node v and all its connected nodes that would not disconnect our current [l, r]. Here, we
use binary-lifting, which is jump to the upmost node that in its subtree there's no active node in range [l, r].
Then we set all nodes from v to that node to 0 using HLD. After that, we check whether the overall LCA is changed
if so, we set all nodes from LCA2's parent to the original LCA to 0.
https://vjudge.net/problem/CodeForces-372D

356. Paint the Tree  (diff=2200, tree dp)
We introduce 2 states for every node, [0] means select at most k edges, [1] means select at most k-1 edges
from the subtree. https://vjudge.net/problem/CodeForces-1223E

357. Say Hello (diff=2300, geometry)
The only hard part about this problem is checking whether there's a point where two points are closer than d1.
This can be done by using the derivatives. https://vjudge.net/problem/CodeForces-1046I

358. Rats (diff=2600, bfs, implementation)
We should observe that each mice can be eliminated only if there's a bomb in the O(d^2) region alongside. 
Hence, we can select a mice, do a BFS and select all the candidates for placing the first bomb. Then, for
all candidates, we do a BFS and see the area that can be blown. After that if a mice isn't covered by the
first explosion, we do a BFS from that mice and get a region for placing the second bomb, then, we do a 
bfs from the second bomb. After that we check whether all mice are eliminated, if so we return the solution.
The overall searching space for this solution is at most 290^3, which 290 is the maximum number of cells
that can be affected with a d-8 explosion. https://vjudge.net/problem/CodeForces-254D

359. Mancunian Candidate Master Forever (Graham scan)
We should observe that this problem is asking the minimum convex-hull that contains all the points, 
then the problem is a standard convex-hull construction problem, which can be solved by using the
Graham scan algorithm. https://vjudge.net/problem/CodeChef-CH

360. Hill Climbing (diff=2200, Graham scan, LCA)
It should be quite obvious that the right hill for every hill is unique, hence the movement graph form a tree.
And the queries can be answered by using binary-lifting LCA. The key to this problem is how to find the right
hill of the current hill. We should immediatelly realize that if we maintain an upper convex-hull using
graham scan, the intersection relationship can be calculated. https://vjudge.net/problem/CodeForces-406D

361. Max and Bike (diff=2400, binary search for final answer, observation)
If you have some physics experience before, you should know that the path length of the detector during T seconds
of jurney is vT + 2rsin(theta). Here, theta is half the radiant - floor(radiant) in T seconds.
https://vjudge.net/problem/CodeForces-594B

362. Delivering Carcinogen (diff=2500, Vertical theorem, cosine law, line interval intersection, binary search)
We can easily see that binary search for final answer works. Then the problem is changed to finding the shortest
distance between two points with a circle as an obstacle. There are two cases, first we can directly move from
one point to another, this case can be solved by using the line segment distance template. Secondly, we can
move from point to the tangent point on the circle then a small arc on the circle and move from the tangent
point to another point. This case can be solved by using the vertical theorem of circles and cosine law.
https://vjudge.net/problem/CodeForces-198C

363. Imbalance Value of a Tree (diff=2400, kruskal modification, tree dp, observation)
We can process the max and min seperately. The thing we are interested in is for every node what are the nodes
that can be reached by only walking through nodes that has weight (less/greater) than itself. This should
remind us about the problem werewolf, we use the kruskal modification procedure and construct a tree.
Then, we do tree dp on the constructed tree to get the final answer.
https://vjudge.net/problem/CodeForces-915F

364. Rectangle Painting 1 (diff=2400, dp)
We define dp[x1][y1][x2][y2] as the minimum cost of coloring the subregion (x1, y1, x2, y2) white. Then,
we should observe that this can be achieved by a cost of max(x2 - x1 + 1, y2 - y1 + 1) or if the entire
region is white the cost is zero. Or we can split the square with some splitting row/col and make those
2 subresions white. The complexity of this approach is O(n^5). The reason this approach won't work for 1198E
(that problem must be solved by using maxflow) is for 1198E n can be upto 1e9.
https://vjudge.net/problem/CodeForces-1198D

365. Sleep in Class (diff=2500, line sweep, observation)
If we draw some examples on paper we should realize the moving trajactory is like this. Let's suppose the starting
cell is 'U', then it would go to the first cell on the right with 'D', then to the first cell on the left with 'U',
and this process repeats until we run out of 'U' on the left or 'D' on the right. The overall cost of moves
can be maintained by a prefix sum vector. https://vjudge.net/problem/CodeForces-733E

366. Maximize Mex (diff=2400, matching)
Something very important to notice is the mex query can be treated as the first position we cannot let matching=
value (i.e. the first position the full flow is not possible). https://vjudge.net/problem/CodeForces-1139E

367. Scalar Queries (diff=2300, math)
The most important for this is simplify f(l, r) as the sum of contribution of a[i] times ord(l, r, a[i]).
Learn some math derivation techniques from this.

368. Robot Arm (diff=2500, matrices and range tree)
The solution to this problem is quite simple. We maintain n vectors, each vector(x, y) represents the relative
direction of point i to point i-1. Then, we can solve this problem using range tree. For each query of type
1, we change the ith position to the required vector, otherwise, we multiply the vector by the rotational matrix.
https://vjudge.net/problem/CodeForces-618E

369. Artem and Array (diff=2500, greedy)
The greedy observation is not that obvious, if there's a number which is less than or equal to both numbers
on the left and right, we can simply remove it. After that we would get a sequence, that's increasing or decreasing
or first increase then decrease or the other way around. In all cases, we can sort the sequence and sum up all
numbers except the last 2. https://vjudge.net/problem/CodeForces-442C

370. Leaf Sets (diff=2400, dsu on tree, small to large, greedy)
The key observation for this is if we maintain the depth of all leaves in the subtree, the more we can group
the leaves, the better. A merge is valid if the sum of the depth of the leaves does not exceed 2d + k, which
d is the depth of the current node and after that the merged node is changed to a single node with depth
max(d1, d2). We can use the small to large/dsu on tree technique, and when we merge the small multiset to the
large one, we iterate from the smaller depth and then always merge to the node that is prev(upper_bound(2d+k-d1)).
This greedy procedure is definitly optimal.
https://vjudge.net/problem/CodeForces-1042F

371. Special Segments of Permutation (diff=2400, small to large)
The key is realizing the small to large trick actually works by some time complexity analysis.
https://vjudge.net/problem/CodeForces-1156E

372. Awards For Contestants (diff=2500, sparse table)
I'm very confused, why this is a 2500 problem? https://vjudge.net/problem/CodeForces-873E

373. Two Segments (diff=2900, sqrt decomposition and line sweep)
Let's define p[i, j] as the total number of segments with values[i, j] such that i is the minimum element.
We could think what would happen if we add element j into the data structure. If would eventually change the
problem to a range update and query total 1, 2 in the range. Which can be done by using sqrt decomposition.
https://vjudge.net/problem/CodeForces-193D

374. Antimatter (diff=2300, knapsack dp)
https://vjudge.net/problem/CodeForces-383D

375. Timofey and our friends animals (diff=2900, range tree, divide and conquer, union find)
The trick we used is exactly the same as the one we used in 811E. We maintain K left end point's parent, K
right end point's parent and the component answer. Then, we should know that we can easily merge 2 intervals
in O(K^2). Hence, we can deal with each query in O(K^2logn). Since K <= 5, this approach works within the 
time limit. https://vjudge.net/problem/CodeForces-763E

376. Convex Countour (diff=2300, interval dp)
We define dp[i][j][0] as the maximum distance when we visit all the nodes [i, j] with i as a starting point.
dp[i][j][1] as the maximum distance when we visit all nodes [i,j] with j as a starting point. Here [i, j] is
a clockwise direction. The key observation for the recurrsive case is if we want to visit [i, j] and start from
i, the second vertex we visit is either i+1 or j otherwise, some vertices cannot be visited.
https://vjudge.net/problem/CodeForces-838E

377. A Dangerous Maze (probability, expected value)
https://vjudge.net/problem/LightOJ-1027

378. Discovering Gold (probability)
https://vjudge.net/problem/LightOJ-1030

379. A Colourful Prospect (diff=2400, Euler's formula, geometry)
We should directly identify Euler's formula can be used in this problem. Then, we should work out the
number of vertices, the number of edges, the number of components seperately. We need to use a new
template circle circle intersection points. https://vjudge.net/problem/CodeForces-933C

380. President's Path (diff=2400, dp)
We should think how to count wisely. Firstly, let's preprocess the all pair shortest path. Then, we can define
a state dp[i][j], which means the number of intermediate nodes k such that edge(i, k) is a shortest path edge
from i to j. Then, we should observe that the answer to ans[i][j] is the sum of all dp[k][j] such that
k is on the shortest path from i to j. This uses the transitivity property of shortest path.
https://codeforces.com/problemset/problem/416/E

381. That Nice Euler Circuit (Euler's formula, geometry)
This is the same as CF933C except we work on segments. https://vjudge.net/problem/UVA-1342

382. Race to 1 Again (probability)
https://vjudge.net/problem/LightOJ-1038

383. Weights Distributing (diff=2400, BFS and greedy)
This problem's observation is quite simple, a->b->c can be viewed as a->i->b->i->c, we check this intersection
point i for all i from 1 to n. https://vjudge.net/problem/CodeForces-1343E

384. Drazil Likes Heap (diff=2400, greedy)
I don't think this is a nice problem. It requires too much guesses.
https://vjudge.net/problem/CodeForces-1329C

385. Kate and imperfection (diff=2200, math, greedy)
We can work in a backward direction. Firstly, preprocess all multiples of i from 1 to n, and record the factors
of all numbers. Then, we scan the gcd from big to small. If there is a multiple chunk has element greater than 1
the answer to that query is that chunk id. Then, we remove the greatest element from that chunk.
https://vjudge.net/problem/CodeForces-1333F

386. Deputies (diff=2400, graph construction)
We should observe that the graph is bipartite. Then, we should know that on each side of the bipartite graph
when we take mod 3, we could get 2 cases 0+0 or 1 +2. The harder one is the 1+2 case. It is either the 1 + 2
nodes that are on the other sides which there's no edge between. Otherwise, we should take 2 + 4 nodes on the
other sides which there's no edge between. https://vjudge.net/problem/CodeForces-173D

387. Subway Innovation (diff=2200, greedy, observation)
The only observation here is the k has to be consecutive, here consecutive means consecutive in x.
https://vjudge.net/problem/CodeForces-371E

388. Microtransactions (diff=2300, greedy, binary search on final answer)
https://codeforces.com/problemset/problem/1165/F2

389. Sonya and Bitwise OR (diff=2400, range tree, observation)
The key observation here is if you do bitwise or from L to R, the resulting value cannot decrease. And
for all segments, the number of unique prefix/suffix bitwise or value can be at most log(a[i]) which is 20.
Hence, the solution is quite simple, we use range tree to do this divide and conquer procedure. We
maintain the unique left prefix and right suffix for each segment, and when we merge, we use a two-pointer
approach. The time complexity for this approach is O((m+n)lognlog(a[i])).
https://vjudge.net/problem/CodeForces-1004F

390. Katya and Segments Sets (diff=2400, persistent range tree, line sweep)
Since this is an online range query problem, we should know the solution might be persistent range tree.
Let's think how to do this problem online. We've done CF524E rooks and rectangles before, the problem works
similar to that. We build a range tree on id. Then, we sort the intervals according to right endpoints.
We do a point update on the corresponding id with max(l, k[i].l), then then answer to the query would be
whether the rangemin(l,r) is greater than q.l. Now let's get back to the online version, we can build a
persistent range tree on the right end points of the intervals, and when we do the query, we query the version
which right endpoint is no greater than q.r. https://vjudge.net/problem/CodeForces-1080F

391. GukiZ and GukiZiana (diff=2400, sqrt decomposition)
The only lesson here is when we use sqrt decomposition, use hashing as few as possible.
https://vjudge.net/problem/CodeForces-551E

392. Alphabet Permutations (diff=2400, range tree, observation)
The key and difficult observation for this problem is, if the string p is sorted 123.... Then, the answer
would be 1 + the number of adjacent pairs of the string such that s[i] >= s[i+1]. Then, you know what to do.
https://codeforces.com/problemset/problem/610/E

393. Tree Painting (diff=2100, tree dp)
2-dfs would solve this. https://vjudge.net/problem/CodeForces-1187E

394. Inna and Babies (diff=2500, line sweep, binary search on final answer)
We can easily see that binary search on final answer works. Then the problem can be reduced to check whether a set of horizontal
segments and vertical segments forms at least 1 rectangle. This can be done with line sweep, CF1194E is the model of this.
Implementation warning: use priority_queue instead of sets as much as possible. https://vjudge.net/problem/CodeForces-374E

395. Array Shrinking (diff=2100, interval dp)
The key to this problem is observing each segment if it can be merged to 1 number, then that number is fixed.
https://vjudge.net/problem/CodeForces-1312E

396. The Maths Lecture (diff=2100, combinatorics)
How to remove double count is the key to this problem. The state definition should be smart.
https://codeforces.com/problemset/problem/507/D

397. Mike and Geometry Problem (diff=2100, combinatorics, line sweep)
The key observation is realizing we can accumulate the intersection length. Firstly, we do the thing we always do in
line sweep problems, point compression. Then, we just need to know for a given subsegment, if the total number of cover 
x is greater than or equal to k. If so, we add c(x, k) * length. 
https://vjudge.net/problem/CodeForces-689E

398. Query on a tree (HLD)
HLD on edges, preparing for CF827d. https://vjudge.net/problem/SPOJ-QTREE

399. Best Edge Weight (diff=2700, kruskal mst, HLD)
We firstly run the MST algorithm and create a tree. Then, we consider 2 cases, what's necessary for a MST edge to
remain in the tree, what's necessary for a non-MST edge to replace an edge in the MST. The second case is simpler.
If a non-tree edge can replace a MST-edge, it should be less than the maximum edge weight in the MST on the path (u, v).
For a MST-edge, it can not be replaced. Hence, we can use HLD here. maintain a range tree, supports range update.
Everytime, we update the weight of edges on the path from (u, v) to min(wt, w(u, v)), here (u, v) stands for all
non-MST edges. https://vjudge.net/problem/CodeForces-827D

400. Progress Monitoring (diff=2300, interval dp)
We define 2 states, dp[i][j][0] as the total number of ways to create trees root with b[i], use nodes in b[i:j].
dp[i][j][1] as the total number of ways to split nodes b[i:j] into forests such that the dfs order is still valid.
Then, the recursive procedure is quite simple dp[i][j][0] = dp[i+1][j][1], while dp[i][j][1] = sum(dp[i][k][0] * dp[k+1][j][1],
which b[i] > b[k+1]). https://codeforces.com/problemset/problem/509/F

401. Dividing Kingdom (diff=2500, persistent range tree, observation)
Before solving this problem, we should know how to count the number of points in a 2d plane in O(logn) time per query. Then, the
key observation to this problem is if we can fix the 2 horizontal and 2 vertical lines, we should immediately check whether that
configuration is valid. Since 9! is around 3e5, we can simply brute force all possible permutations and then use binary search
to get the 2 horizontal and vertical lines. Finally, use the 2d plane trick to validate. The complexity of this solution is
O((n+9!)logn). https://vjudge.net/problem/CodeForces-260E

402. Sign on Fence (diff=2500, persistent range tree, divide and conquer)
There are 2 key observations, first we can binary search on final answer. Secondly, the validation can be done by checking
whether [l, r] the maximum continuous length of v is greater than or equal to w. Here, if we create a persistent range 
tree with height in decreasing order as versions, the problem would be solved. 
https://vjudge.net/problem/CodeForces-484E

403. Bear and Floodlight (diff=2200, bitmask dp, geometry)
This problem is quite trivial bitmask dp, we define dp[mask] as the maximum right hand side when using the lights in the
subset of mask. And when we do state transition, it is just a very simple geometry problem, sine laws and cosine laws are
used. https://codeforces.com/problemset/problem/385/D

404. Phoenix and Science (diff=1900, constructive algorithm)
When we see n=1e9, and the construction procedure has some relationship between powers of 2, we should always try
1,2,4,8... construction. https://vjudge.net/problem/CodeForces-1348D

405. Carousel (diff=1800, constructive algorithm)
When we are dealing with coloring problems, always think is it possible to change the problem to a bipartite graph.
https://vjudge.net/problem/CodeForces-1328D

406. Dreamoon Likes Coloring (diff=1800, constructive algorithm)
Greedily construct. https://vjudge.net/problem/CodeForces-1329A

407. Make Palindrome (diff=1800, constructive algorithm)
Palindrome problem always use this property, it allows only 1 type of alphabet that has odd occurence.
https://vjudge.net/problem/CodeForces-600C

408. Phoenix and Memory (diff=2600, line sweep, greedy)
The first observation is we can construct an answer visa line sweep and greedy. Sort according to left. Then, every time extract
the one with smallest right. Then, we need to know how to validate whether the answer is unique. The answer is definitly not unique
if the following thing can happen. A later extract element is covering an id before the smallest right bound. Now we need to show this is
also the only condition for the non-uniqueness to happen. This can be proved by pigeon hole principle. 
https://vjudge.net/problem/CodeForces-1348F

409. Jamie and Tree (diff=2400, range tree, LCA, observation)
The key problem here is figuring out what would happen if the root of the tree is changed to an LCA. If we draw the diagrams of several
trees, we should realize that only the nodes that are on the path from 1 to the new root can be affected. After that we can use
the property dist(u, v) = dist(u, root) + dist(v, root) - 2 * dist(lca, root) to find the new LCA.
https://vjudge.net/problem/CodeForces-916E

410. A Mist of Florescence (diff=1800, constructive algorithm)
The process is like painting. https://vjudge.net/problem/CodeForces-989C

411. High Load (diff=1800, constructive algorithm)
Construct from leaf to root. Using the fact that all nodes can have at most 1 parent.
https://vjudge.net/problem/CodeForces-827B

412. Vasya And The Matrix (diff=1800, constructive algorithm)
We use the calculate twice trick. Suppose that there is a solution, then the xor of all a[i] must equal to the xor of
all b[i]. Hence, we can put a[i] on all first element of each row except the last one, and b[i] on all columns of the
last row except the first one. That intersection element can be calculated using b[1] ^ (a[1] ^ ... ^ a[m-1]).
https://vjudge.net/problem/CodeForces-1016D

413. Maximum Diameter Graph (diff=1800, constructive algorithm)
The weakness of this problme is a[i] is the upper bound! So if we create a long line, it would only make the answer better.
https://vjudge.net/problem/CodeForces-1082D

414. Harmony Analysis (diff=1800, constructive algorithm)
We know that for an orthogonal matrix AA_T = V. here V is a diagonal matrix. We used a divide and conquer approach.
We put (AA|A-A) in a matrix of size 2A. https://vjudge.net/problem/CodeForces-610C

415. Shovel Sale (diff=1800, constructive algorithm)
https://vjudge.net/problem/CodeForces-899D

416. New Year Tree Decorations (diff=2500, geometry, line sweep)
The geometry knowledge that should be used in this problem includes line-line intersect, calculating y coordinate given x
and a line. Key observation for this problem is, we can maintain the polyline for the previous i-1 shapes when calculating 
the area of the ith shape. https://codeforces.com/problemset/problem/379/E

417. T-shirts Distribution (diff=1800, constructive algorithm)
This is the process of greedily construct the perfect matching.
https://vjudge.net/problem/CodeForces-727D

418. Marco and GCD Sequence (diff=1900, constructive algorithm)
The observation here is the -1 case only happens when the smallest gcd is not a gcd of the other gcd.
Then, we can build the sequence with a[1] a[2], a[1], a[3], a[1], a[4]...
https://vjudge.net/problem/CodeForces-894C

419. Complete Tripartite (diff=1900, constructive algorithm)
Just be careful on all edge cases. 
https://codeforces.com/contest/1228/problem/D

420. Extending Set of Points (diff=2600, union-find, range tree on queries)
This problem might seems extremely hard at first. Let's think what would we do if there's only add queries.
We should observe that for each x it contains several y, when two x shares the same y, we could join them together
and the resulting extension would be the sum of there width times the sum of there height. Hence, we could use
union find to solve the problem. Since general deletion is impossible for dsu, we simply use range tree to help.
Since this approach is outlined in many many other problems in the list, I would not repeat it again.
https://vjudge.net/problem/CodeForces-1140F

421. Regular Bridge (diff=1900, constructive algorithm)
For even degree, return No. otherwise, build something look like 2 complete graphs with a bridge connecting in the middle.
https://codeforces.com/contest/550/problem/D

422. Simple Subset (diff=1800, constructive algorithm)
There are only 3 cases. Many 1 and one even number, two numbers that sum up to prime, 1 number.
https://vjudge.net/problem/CodeForces-665D

423. Magic Grid (diff=1800, constructive algorithm)
https://vjudge.net/problem/CodeForces

424. Looking for Owls (diff=2400, geometry, binary search)
The idea of this problem is quite simple, we group the lines into y=kx+b chunks, and each pair of valid
circles, we just count the number of lines that are prependicular to the line connecting the circles,
and have an intersection point. The hardest thing though, is the floating point numbers are inaccurate.
Hence, we should write our own fraction class and work on integers.
https://vjudge.net/problem/CodeForces-350D

425. Tolik and His Uncle  (diff=1800, constructive algorithm)
https://vjudge.net/problem/CodeForces-1179B

426. Vasya And Array (diff=1800, constructive algorithm)
Something we should realize is if there is a total overlap between sort and unsort range the answer should
be -1. We can treat sort query as union of ranges, and then we can construct the ranges in the following 
way, in general a descending order, if the left, right element are in the same component make them equal.
https://codeforces.com/problemset/problem/1187/C

427. Paint the Tree (diff=1800, constructive algorithm)
When there are 3 items/vertices in a row, try to see what's special about the middle one.
https://vjudge.net/problem/CodeForces-1244D

428. Minimum Euler Cycle (diff=1800, constructive algorithm)
Pattern finding. https://vjudge.net/problem/CodeForces-1334D

429. Optimize! (diff=2600, range tree, observation)
The code is actually describing a brute force matching procedure. It is actually asking to following quetion.
How many length len subarray of a[] satisfy that there is a perfect matching with array b. Two element can be
connected iff a[i] + b[j] >= h. We should realize that this is exactly the same as CF1179C. We are looking for
the largest index such that the number of b[i] is more than the number of a[j] that requires a match.
https://vjudge.net/problem/CodeForces-338E

430. Maximal Area Quadrilateral (diff=2100, cross product)
We just iterate over all the diagonals and use the cross product to update areas.
https://vjudge.net/problem/CodeForces-340B

431. Monopole Magnets (diff=2000, constructive algorithm)
There's definitly no solution if a row has no # and there's no column has no #, and vice versa. Besides,
there's no solution if in any row/col . is surrouded by #. Otherwise, the answer would be the number of #
connected components. https://vjudge.net/problem/CodeForces-1344B

432. Function (diff=2900, CHT-trick and range tree)
We should realize that the optimal path must be a vertical path plus a 45 degree diagnal path, this can be
proved by contradiction. After that we should express the path cost(i, j) as some function on the prefix sum
of a and optimal turning point k. Then, we should realize the function can be calculated quickly by using 
CHT. Since the function has a valid input range, we should use range trees of CHT to solve it, just like
CF91E. https://vjudge.net/problem/CodeForces-455E

433. Drazil and Tiles (diff=2000, constructive algorithm, BFS)
The key observation here is if there's no force move, there should be at least 2 solutions. Here, force move
means degree 1 vertex. If there is a degree 1 vertex, we can simply math it with the only connection vertex u,
and then repeat this process using BFS. https://vjudge.net/problem/CodeForces-515D

434. Time to Run (diff=2000, constructive algorithm)
We should immediately realize that the graph exists an Euler path, and it looks like a S-shape.
https://vjudge.net/problem/CodeForces-1301D

435. Polygons (diff=2100, point in convex polygon)
This is a template problem, just be careful about the on segment edge case.
https://vjudge.net/problem/CodeForces-166B

436. Equalizing Two Strings (diff=2000, constructive algorithm)
Key observation here is there are only 3 cases to be considered, frequency of characters is not the same.
One string has a character occurs more than once. The odd/even of inversion pairs.

437. Petya and Construction Set (diff=2000, constructive algorithm)
Well, the problem says all di are less than or equal to n. Think how to use this constraint!
https://vjudge.net/problem/CodeForces-1214E

438. Dasha and Puzzle (diff=2000, constructive algorithm)
We should note that only if a vertex has degree greater than 4, we should print NO. Then, the problem is
how to construct the tree, we should walk from vertex 1, and walk with a step of 2^i in 4 directions.
https://vjudge.net/problem/CodeForces-761E

439. New Year Domino (diff=2300, range tree, line sweep)
The observation is much harder than the implementation. We should observe that a domino is going to cover
the range [pi, pi + li], hence, there's a non-trivial reduction to this problem, cover [l, r] by segments.
Query [l, r] how many empty points in total. This can be done by range tree and line sweep.
https://codeforces.com/problemset/problem/500/E


*Term 2 training May 12, 2020 to July 31, 2020*

440. DFS (diff=2700, range tree, observation)
We should observe that in all trees, a newly added edge can be ignored without changing the dfs tree,
only if it is an edge connecting the u, v which u is an ancestor of v or the other way around.
https://vjudge.net/problem/CodeForces-1044F

441. Dreamoon and Sets (diff=1900, constructive algorithm)
https://codeforces.com/problemset/problem/476/D

442. Maximal GCD (diff=1900, constructive algorithm)
https://codeforces.com/problemset/problem/803/C

443. Coloring Edges (diff=2100, constructive algorithm, dfs)
There are 2 types of important edges in dfs, forward edge and back edge. We'll make all forward edges
1, and all back edges 2, this would make the graph cycle free.
https://vjudge.net/problem/CodeForces-1217D

444. Robots on a Grid (diff=2200, binary lifting, functional graph observation)
We should realize the graph is a functional graph, hence after 2e6 moves (double the size of the grid), 
all robots would ended in the cycle component of each functional graph. Therefore, the number of unique
points after 2e6 moves would be the answer. https://vjudge.net/problem/CodeForces-1335F

445. Petya and Pipes (diff=2600, MCMF)
After this problem, we should know that MCMF algorithm can find the max flow with cost no greater than K.
https://vjudge.net/problem/CodeForces-362E

446. Lovely Matrix (diff=2200, dfs, graph construction)
This is a stunning problem. We should have the initial observation that the problem can be solved by using
topological sort. However, the graph construction can not be done by brute force. The problem only has a 
constraints that mn <= 1e5, which means m can be up to 1e5, if we construct the graph by a simple brute
force, O(nm^2) complexity would be too high. So, what we can do is construct procedure graph, unique the
none -1 entries for each row and sorted them in increasing order, then we connect v1_in ->(all index with v1 in current row) -> v1_out->v2_in ... This would make the final time complexity O(nmlogm).
https://vjudge.net/problem/CodeForces-274D

447. Berland Beauty (diff=2100, constructive algorithm)
We sort the requirments in ascending order, and then just set the path(u, v) to wi. Then, set all unmodified
edges to 1e6. Finally check whether all constraints are satisfied. Since this is just a div 3 problem, n=5e3,
we can actually handle n up to 2e5 by using HLD. https://vjudge.net/problem/CodeForces-1296F

448. Orac and Medians (diff=2000, constructive algorithm)
https://vjudge.net/problem/CodeForces-1349B

449. Boring Partition (diff=1800, constructive algorithm)
Observe smallest and largest numbers. https://vjudge.net/problem/CodeForces-238B

450. Fox And Dinner (diff=2800, flow)
The observation is we can definitly seperate odd/even numbers, but the trick thing here is if we select
(u, v), we cannot select(v, u). The trick here is we add edges from source to odd numbers with capacity 2,
add edges from even numbers to sink with capacity 2, prime(u, v) are connected with capacity 1 edges.
The thing it is trying to model is, every odd number contributes to 2 pairs, every even number contributes
to 2 pairs, since |odd number| must equal to |even number|, the matching must be groups of cycles.
https://vjudge.net/problem/CodeForces-510E

451. Minimal k-covering (diff=2500, flow)
Initially I was thinking this as some kind of min-cut problem on edges, but it seems we are not using the
bipartite graph condition. Then, by drawing some examples, we should realize that the amount of edges
selected is exactly the same as the mincut/maxflow of the bipartite graph. Hence, instead of thinking 
what's the minimum amount of edges to delete in order to make all vertices to have degree k, we can think
what's the maximum amout of edges (max flow) that can be deleted so that each vertex would lose degree
no more than deg[v] - k. To speed up our algorithm, we can work backward (decreasing order of k), each iteration add 1 to all capacities from s to u, v to t by 1. The overall complexity of the algorithm would be limited to O(m^2). https://vjudge.net/problem/CodeForces-976F

452. Mobile Phone Network (diff=2600, kruskal, HLD)
The observation here is we can form the minimum spanning tree with all f edges included using Kruskal.
And then, each non tree edge is simply a set path query, set the weight of all edges in the path u, v
to min(w, original weight). After that, we simply sum up all the weights and get the solution. Don't forget
to minus the g edges. https://vjudge.net/problem/CodeForces-1023F

453. Optimal Number Permutation (diff=1900, constructive algorithm)
There is a weakness here, n can be placed anywere with a cost of 0. 
https://vjudge.net/problem/CodeForces-622D

454. Idempotent functions (diff=2000, constructive algorithm)
https://codeforces.com/problemset/problem/542/C


455. Tidying Up (diff=2300, MCMF)
I had the initial observation, divide the graph into 2 parts, (x, y) with x + y is even to one part, 
x + y is odd to the other part. Then, the most important observation is the answer is exactly the same
as the minimum number of unmatched pair in the square. unmatch here means two cells are neighbours and
they are not the same color. https://codeforces.com/problemset/problem/316/C2

456. Four Melodies (diff=2700, MCMF)
We can use MCMF to solve this problem, the interpretation is as follows, every node should have a vertex capacity
of 1 and vertex cost of 1, two nodes are connected if i < j and a[i] and be followed by a[j] according to 
the definition. There should be at most 4 starting points. One thing to notice is SPFA can be killed by the 
time limit, we must use dijkstra with potential to optimize our code!
https://codeforces.com/contest/818/problem/G

457. Shortest and Longest LIS (diff=1800, constructive algorithm)
https://vjudge.net/problem/CodeForces-1304D

458. Neko and Flashback (diff=2400, Euler path)
We should have an intial observation that b[i] > c[i] would lead to no solution. Consider a pair (b[i], c[i]),
we know that in the initial sequence, there must exists a pair b[i] next to c[i]. In total there are n-1 such
constraints. We should observe that there should be a sequence of traversal such that we can fulfill these
b[i] next to c[i] constraints one after another. This is an Euler traversal! Hence, we establish the graph,
and check 1) the graph is connected, 2) the graph has an Euler path/circuit. Then, we apply the Hierholzer's
algorithm and find the euler path. https://vjudge.net/problem/CodeForces-1152E

459. Summoning Minions (MCMF)
There are several important observations on this, 1) there are k selected items and n-k unselected items,
the maximum cost you can achieve is by placing the items in the order (k-1 selected)_n-k unselected_1 selected.
2) the maximum cost under this configuration is a[v1] + a[v2] + ... + a[vk] + b[v1] * 0 + ... + b[vk] * (k-1)
+ sum(b[u] * (k-1), u not in {v}). 3) The maximization can be done by a standard MCMF.
https://codeforces.com/contest/1354/problem/F

460. Two Paths (diff=2600, Euler path)
The resulting paths are two euler paths in the graph, we just need to do several case differentiation
and use the Hierholzer's algorithm to find the solution. 
https://vjudge.net/problem/CodeForces-36E

461. Sum of Nestings (diff=1800, constructive algorithm)
Greedily construct. https://codeforces.com/problemset/problem/847/C

462. New Year and Rainbow Roads (diff=2400, Greedy)
Just a case differentiation. https://vjudge.net/problem/CodeForces-908F

463. Graph Coloring (diff=2100, dfs bipartite graph, knapsack dp)
The observation is as follows, for all edges one vertex must be 2 while the other must be (1, 3), this applies
to all edges. Hence, we can decompose the graph into many bipartite components, each bipartite graph, one
part of the vertices is filled with 2 while the other part is filled with 1 and 3. To make the assignment valid,
2 conditions must be satisfied, firstly, the graph is bipartite, this can be checked by dfs. Secondly, if we
select one part of each component, we are able to get n2, this can be done by a simple knapsack dp.
https://vjudge.net/problem/CodeForces-1354E

464. Weird journey (diff=2100, observation, constructive algorithm, Euler path)
The observation is if all paths are used twice except 2, this means that if there is a directed Euler path
in the graph there's exactly one outdeg-indeg=1 vertex and one outdeg-indeg=-1 vertex. We can consider
which edges can be removed at the same time, it is either v1->v2->v3 or one self cycle and one arbitary edge.
https://vjudge.net/problem/CodeForces-788B

465. Underground Lab (diff=2100, constructive algorithm)
The key observation on this is we can change the problem to the construction on the dfs tree. Since, for every
tree there's at most 2n nodes visited during the Euler tour, the problem is doable.
https://vjudge.net/problem/CodeForces-780E

466. Runaway to a Shadow (diff=2500, geometry)
This is simply asking the union of intersection angles. https://vjudge.net/problem/CodeForces-681E

467. Santa Claus and a Palindrome (diff=2100, Greedy)
The most important information here is all strings have equal length. Then, we should think how a palindrome
can be formed. Either concatination of a string and a reverse string or a single palindrome string in the middle.
https://vjudge.net/problem/CodeForces-748D

468. Brackets in Implications (diff=2200, constructive algorithm)
https://vjudge.net/problem/CodeForces-550E

469. Little Elephant and Triangle (diff=2500, geometry, counting)
This problem is much harder than it looks. There is a very tricky case to handle, all 3 points are at the
same position, instead of subtract 6, we only subtract 1.
https://vjudge.net/problem/CodeForces-220D

470. Santa Clauses and a Soccer Championship (diff=2300, constructive algorithm)
https://vjudge.net/problem/CodeForces-748F

471. Little Pony and Summer Sun Celebration (diff=2200, constructive algorithm)
Again, Euler tour. https://vjudge.net/problem/CodeForces-453C

472. Wizard's Tour (diff=2300, constructive algorithm)
We should observe that if we greedily match the edges into groups of 2 while letting the parent edge
has the least priority, we could easily get a solution of size m/2 for each connected component.
https://vjudge.net/problem/CodeForces-861F

473. Graph Cutting (diff=2300, constructive algorithm)
Exactly the same as the previous one. https://vjudge.net/problem/CodeForces-405E

474. Tanya and Password (diff=2500, Euler path)
For this kind of word connection problems, we just apply the standard Euler path trick. For every
word s, we connect an edge from eocode(s[0,1]) to encode(s[1,2]). And then run the popular Hierholzer's
algorithm to find the directed euler path/cycle in the graph. 
https://vjudge.net/problem/CodeForces-508D

475. Magic Matrix (diff=2400, observation, Kruskal algorithm, binary-lifting)
I'm very excited that I can solve this problem by myself. The observation is we can firstly check the matrix
is a symmetric matrix and then after rewrite the condition to a[i][j] <= max(a[i][k], a[k][j]), we use graph
to interprete this, it is the complete graph formed by this matrix satisfies all length 3 cycles with length
(a, b, c) (suppose a >= b >= c) satisfies a=b and b >= c. If we are familiar with MST, this also means that
all edges in this complete graph can be a MST-edge ! After that we simply use the standard binary-lifting
trick to finish off this problem. https://vjudge.net/problem/CodeForces-632F

476. Little Victor and Set (diff=2300, constructive algorithm)
The observation we use is for any even number x ^ (x + 1) = 1, hence for k>=4, the construcion is very simple.
The toughest case is dealing with k = 3. Here, after some pattern finding, I realize only 
(2^k - 1) (2 ^ k * 3 / 2 - 1) (2 ^ k * 3 / 2) are useful tuples, we can simply check if there's such tuples
in the range(l, r), if not we just print the answer for k=2.
https://vjudge.net/problem/CodeForces-460D

477. Destroy it! (diff=2100, knapsack dp)
https://vjudge.net/problem/CodeForces-1176F

478. Playing the ball (diff=2600, geometry)
We should know that each circle can be valid in an initial angle range, and the maximum number of times
it can contribute to the final answer is 2 * 50 / 5 = 20. Only be careful about negative angles.
https://vjudge.net/problem/CodeForces-420E

479. Bombs (diff=2400, line sweep, observation)
The key observation is the answer must be non-increasing. Now, let's think how to check whether v is the answer.
Instead of thinking whether v can exists in the set or not, we should think whether all elements from v to n
are removed or not. With these 2 observations, especially the second, the problem can be solved by a standard
line sweep and range max tree. https://vjudge.net/problem/CodeForces-1326E

480. Network Safety (diff=2200, union find, counting)
Let's think when can the virus affect two nodes (u, v), we know that this would happen only if x = u ^ v, and
one of u, v is infected. Hence, we can solve each such x seperately, in total O(m) of them. For each x, 
we apply union-find procedure, and make the n nodes into cnt connected components (total s nodes) that would affect the final answer, and 1 component (n-s) nodes that would not make any difference to the final answer.
We should observe that x would not make the connection invalid if we apply the xor operator to any of the
cnt connected components as a whole (xor all numbers in the a complete connected component by x). 
Then, we can get the final answer. https://vjudge.net/problem/CodeForces-1039C

481. Ice cream coloring (diff=2200, constructive algorithm)
There's a strange sentence in the problem statement "Vertices which have the i-th (1 ≤ i ≤ m) type of ice cream form a connected subgraph". We need to think what's special about this. Note that without such sentence, the
problem is NP hard. We should have the following 2 observations, 1) for a complete graph, the minimum number
of colors for the graph coloring is |V|. 2) if the same ice cream form a subgraph, (connected tree), greedily
coloring would work, i.e. no blocking case might occur. 
https://vjudge.net/problem/CodeForces-804C

482. Fake News (medium) (diff=2200, constructive algortihm)
Observe that if we choose p="bbba", and the total subsequence can be made up of c(n, 3), which would solve
the problem. https://vjudge.net/problem/CodeForces-802H

483. Data Center Drama (diff=2600, constructive algorithm, Euler path)
Firstly, I observed that since all vertices have even in and out degree, the graph must have an Euler tour.
And at the same time the total number of edges must be even. Hence, we can use the standard trick to make
the graph to have an Euler tour, and add a (1, 1) edge if the total number of edges in the modified graph is odd.
Now, let's think how to construct the answer. We can run find the Euler tour, and for the edges with odd id, 
we print the original direction, for the edges with even id, we reverse it. This is correct if we consider the
degree contribution of edges. https://codeforces.com/problemset/problem/527/E

484. Tree Destruction (diff=2400, constructive algorithm, greedy, LCA)
I found some interesting properties on this. firstly, if the tree is a link list, the answer is simply every time
remove one of the end point for n-1 times. then, let's consider the following constructive process
1) find the tree's diameter, then remove all the points not in the diameter
2) remove the diameter according to the way in the intuition.
let's think why this is correct, for the non-diameter nodes let u, v be the two end points of the diameter
consider a node w not on the diameter its distance with the closest point on the diameter p is d1, and dist(p, u) = d2, dist(p, v) = d3 suppose that d2 >= d3. Then d1 + d2 <= d2 + d3 and d1 + d3 <= d2 + d3 by definition.
What's more, let's suppose there exists there's a node in the subtree of p has d4 + d1 >= d1 + d2
this would form a contradiction. Hence, all nodes not on the diameter can achieve tha maximum cost.
For a single list we left, the longer it is the larger the cost we can achieve. Hence, the construction is optimal.
https://codeforces.com/problemset/problem/911/F

485. Earth Wind and Fire (diff=2300, constructive algorithm)
The first response to this problem should be sorting. After that we should observe that one one match would
definitly be the correct solution. https://vjudge.net/problem/CodeForces-1148E

486. Anton and Ira (diff=2300, constructive algorithm)
There are 3 observations and if we combine them together, the problem is solved.
1) the number of swaps is bounded by c(n, 2) which is less than 2e6 using the property of bubble sort
2) when we are doing sorting, some elements move forward and some elements move backwards, to minimize
the total cost, we just need to make sure no elements move forward and then backward again or the otherway.
3) greedily construct from s[1] to s[n] can always satisfy 2).
https://vjudge.net/problem/CodeForces-584E

487. Graph and String (diff=1800, constructive algorithm)
The idea is construct a reverse graph, it is every edge not in the graph, add an edge in this new graph.
Then, the new graph must be bipartite. We fill this graph with a and c, for the uncolored nodes, we filled
with b. Finally, we check whether all conditions are satisfied. 
https://codeforces.com/problemset/problem/623/A

488. Mike and distribution (diff=2400, constructive algorithm)
Quite hard. https://codeforces.com/contest/798/problem/D

489. Dating (diff=2300, line sweep, Mo's algorithm on the tree)
Firstly, you should learn how to do Mo's algortihm on a tree. Secondly, for this problem, if the queries
are on a stright line, it is a template Mo's algorithm problem. Try to combine the Mo's algorithm template
and Euler tour would give the correct answer. https://vjudge.net/problem/CodeForces-852I

490. Edges in MST (diff=2300, Kruskal algorithm, HLD)
This is such a routine MST problem, just determine whether an edge can be replaced.
https://vjudge.net/problem/CodeForces-160D

491. Vus the Cossack and a Graph (diff=2400, constructive algorithm, Euler path again and again)
https://vjudge.net/problem/CodeForces-1186F

492. Mike and Fish (diff=2600, constructive algorithm, bipartite graph)
The intuition is to make the graph only contains even cycle, this would make a point and its adjacent
point to have different color. Let's construct the graph by connecting v[x][i] and v[x][i^1] for each 
group of nodes. This would make the graph has no odd cycle and each group of adjacent nodes would have
different color. https://vjudge.net/problem/CodeForces-547D

493. Arpa’s overnight party and Mehrdad’s silent entering (diff=2600, constructive algorithm, bipartite graph)
Again, this problem is supposed to be a bipartite graph, however, there might be odd cycles. Then, for the
edges on the circle, we only add half of them, this would make the graph bipartite and all groups of adjacent
nodes the color must be different within the group, which by pigeon hole principle we have a valid construction.
https://vjudge.net/problem/CodeForces-741C

494. Envy (diff=2300, MST property)
There's a property that can be used for MST, for each weight X, if all the edges with weight X-1 are added in by
Kruskal algorithm, the connectivity is the same (independent of the order of adding edges). Hence, this problem
can be done offline. Instead of answering queries by queries, we answer the question weights by weights.
https://vjudge.net/problem/CodeForces-891C

495. Yaroslav and Sequence (diff=1800, constructive algorithm)
https://vjudge.net/problem/CodeForces-301A

496. Mass Change Queries (diff=2500, range tree on swapping queries)
This is not a standard range tree problem. We maintain tree[index].to[i] means in this l, r range which
value is i mapped to. Then, when we do updates, we change all i such that tree[index].to[i] = x to y.
And when we do the pushdown operation, we do tree[left].to[i] = tree[index].to[tree[left].to[i]], which
means that in the left range i is initially mapped to j, now it is mapped to where j is map to in the
parent range. https://vjudge.net/problem/CodeForces-911G

497. Kuroni and the Score Distribution (diff=2200, constructive algorithm)
We can greedily construct the answer. The final sequence look like 1, 2, 3..., X (a bit of math), {large odd numbers}. https://vjudge.net/problem/CodeForces-1305E

498. Opening Portals (diff=2600, kruskal algorithm and dijkstra algorithm)
This problem is very similar to CF1253F. We consider the simpliest case, when all n nodes are special nodes.
This would be the MST of the graph. Hence, MST should be the direction of this problem. We change the 
edge weight of each edge to w + dist[from] + dist[to]. Here, the dist array is the shortest path distance
from the k special nodes to all other nodes. Also, we should change from to origion[from] and to to origion[to].
Here, origion array records the optimal starting nodes. After that we just run kruskal and if 1 is not a special
node, we add dist[1] to the answer. https://vjudge.net/problem/CodeForces-196E

499. Flights (diff=2600, system of different constraints)
The condition for all edges on path 1 to n are points on the shortest path from 1 to n is
dist[e.from] + w = dist[e.to], here dist[i] refers to the shortest path from 1 to n. Where w is between 1 and 2.
Hence, we can use system of different constraints to solve this.
https://vjudge.net/problem/CodeForces-241E

500. Numbers on Tree (diff=1800, constructive algorithm)
We could interpret the C[i] value as follows, if we sort all the values in the subtree of i, i has rank c[i].
Then, instead of trying to calculate what value for each i, we can get the rank of i first and then fill the numbers. https://vjudge.net/problem/CodeForces-1286B

501. Neatness (diff=2400, constructive algorithm)
After playing with several examples, we should realize that we can do dfs first and fix the cell we move through
to 1 and when we backtrack we fix the cell to 0. There's a solution iff there's no 1 in the grid after this
procedure. https://vjudge.net/problem/CodeForces-359E

502. The Cake Is a Lie (diff=2400, constructive algorithm, topological sort, BFS)
We should observe that the starting cut must be a cake with no more than 1 shared edge. We start from this piece,
do a BFS, two cakes are called connected if there is a shared edge. During this process we establish a graph
describing the partial order of the vertices, and do a top-sort on that to get the p. Finally, to get the q array,
we simply start from the cake with the least amount of shared edges, cut it first and decrement the common edge
of its neighbours, repeat this process until no cakes left. https://codeforces.com/problemset/problem/1282/E

503. Money Transfers (diff=2100, greedy, dp)
The observation is for any interval with sum 0, we can do this with len-1 times, len is the total elements in
the interval. Hence, we want to find the partition of the original cycle such that the number of sum=0 subinterval
is maximized. This is a very simple dp, can be done with the help of a map. 
https://vjudge.net/problem/CodeForces-675C

504. Number of Components (diff=2100, dp, combinatorics)
This is a special counting problem, instead of thinking how many components for each range, we think
components=vertices-edges. Then count the vertex contribution and edge contribution seperately.
https://codeforces.com/problemset/problem/1151/E

505. K-th Path (diff=2200, floyd, observation)
The property we are using here is the kth pair-wise shortest path is only related to the first k smallest edges.
We should create a sparse graph first, then solve the problem using Floyd algorithm.
https://vjudge.net/problem/CodeForces-1196F

506. A/B Matrix (diff=1900, constructive algorithm)
We can easily split the testing data into yes/no, by checking whether n * a = m * b. After that we do a greedy
construction procedure, each time, we select the a least coloring colunm and color them to 1.
Then complexity for this construction procedure is O(Tnmlogn).
https://vjudge.net/problem/CodeForces-1360G

507. Binary Median (diff=2100, constructive algorithm)
https://codeforces.com/problemset/problem/1360/H

508. Inverse Coloring (diff=2100, dp)
The observation is if we know the first row, all the other rows must be the same/completely differnet.
https://codeforces.com/contest/1027/problem/E

509. Magic multisets (diff=2500, range tree, observation)
This problem is very tricky. The most important observation is, we can firstly assume all updates
are double the range sum. And then for the index which no such x exists, we update the range by time
the inverse of 2 and plus 1. https://vjudge.net/problem/CodeForces-981G

510. Garlands (diff=2400, 2d fenwick tree, observation)
Here we should target on the condition |ask| <= 2000. We know that there are at most mn light bulbs in total.
And the light bulbs in the same garland can only be on/off at the same time. Hence, we can calculate the 
contribution of each garland to each query seperately in an offline way. This would make the complexity
2000klognlogm. https://vjudge.net/problem/CodeForces-707E

511. Splitting the Uniqueness (diff=2400, constructive algorithm)
https://vjudge.net/problem/CodeForces-297C

512. AND-permutations (diff=2500, constructive algorithm)
Two observations: even & even + 1 is not 0, i & (2^k - i) is 0.
https://vjudge.net/problem/CodeForces-909F

513.  Restoring Numbers (diff=2200, constructive algorithm)
By playing with examples, we have the following observations, firstly, we can fix b array,
by simply filling with the first row of the matrix. Secondly, we should pay attention
to g[i][j] and g[i][j+1], this would decrease k to a suitable value.
https://codeforces.com/problemset/problem/509/D

514. Beautiful Rectangle (diff=2300, constructive algorithm)
Firstly find the dimension, this can be done by sweeping. Secondly, fill in the numbers from the higher frequency
number to the lower frequency number in a diagonal shape. https://vjudge.net/problem/CodeForces-1276C

515. Set of Points (diff=2300, constructive algorithm)
https://vjudge.net/problem/CodeForces-277B

516. Beautiful Road (diff=2300, union-find, dp on tree, line sweep)
It is not hard to see that solving this problem online for each edge in dfs order seems stupid. Intead, we 
can solve this problem in an offline, line sweep manner. Firstly, sort the edges according to their weights
and maintain a union-find with size structure. Then, each time, when we add in a type of edges, we create
a sparse forest, and run 2 dfs on that sparse forest to get the answer for each edge.
https://codeforces.com/problemset/problem/87/D

517. K Integers (diff=2300, range tree, order statistics)
We can think what's the solution to k=n, the solution is simply the total number of inversion pairs in the array.
Then let's consider how to solve k < n in general. The only difference is there are elements from k+1 to n in
the subarray. We should observe that some of these waste elements should move leftward, while others move rightward. Then to make the total number of moves minimum, there must be a pivot, i.e. all the waste elements
on the left of this pivot moves left, while all the elements on the right of this pivot moves right. With
this observation, the problem is turned into a quite standard counting problem.
https://vjudge.net/problem/CodeForces-1268C

518. Down or Right (diff=2100, constructive algorithm)
We use the following trick, for the first half of the path, simply walk to the point the Manhattan distance
to (n, n) is n - 1. Then, we do a reverse traversal from (n, n). And the key here is to explore the
2 direction in an opposite way i.e. if you prioritize R to D in the first half of the path, you should
prioritize D to R in the second half of the walk.
https://vjudge.net/problem/CodeForces-1023E

519. Lexicography (diff=1800, constructive algorithm)
The key observation here is the order of 2 strings are determined by the first different character.
https://codeforces.com/problemset/problem/1267/L

520. Running in Pairs (diff=2400, constructive algorithm)
Greedily construct. https://vjudge.net/problem/CodeForces-1244G

521. Subarray Sorting (diff=2400, constructive algorithm)
There are 2 key observations, firstly sorting can be achieved by swapping adjacent elements, secondly,
the leftmost position an element can go is determined by the range min of its left elements.
https://codeforces.com/contest/1187/problem/D

522. MST Company (diff=2400, binary search, kruskal modification)
This problem is very tricky. We can make the following claim, if we increment all edges that connects 1 and
some other vertices by +x, the MST for the k-degree tree has larger weight than the MST of the k+1 degree tree.
Hence, we can binary search on this x, and find the largest x such that we can have a k-degree tree.
https://codeforces.com/problemset/problem/125/E

523. Last chance (diff=2500, max flow, range tree graph construction)
The intuition of this problem is actually quite simple, just use the range tree graph construction technique
to build the graph and for the type 3 weapon, the capacity of the node is 2. It is quite simple to proof the
max flow is equal to the answer. The hard part however, is finding the correct matching. We do a reverse dfs
for each weapon, only walk the residual edges and each time if the residual edge has flow < 0, we increment the
flow and walk up. https://vjudge.net/problem/CodeForces-1045A

524. Competition (diff=2200, greedy)
https://vjudge.net/problem/CodeForces-144E

525. The Coronation (diff=2300, bipartite graph, dfs)
This trick is now getting too old. https://vjudge.net/problem/CodeForces-1250E

526. Searching Rectangles (diff=2200, constructive algorithm)
I'm not going to implement this, because it is tedious. The main idea here is horizontally and vertically
there must be at least 1 direction such that you can draw a line that seperate the 2 rectangles.
You found this seperate line and then do 8 binary search to get the solution.
https://vjudge.net/problem/CodeForces-713B

527. Problem for Nazar (diff=1800, constructive algorithm)
https://vjudge.net/problem/CodeForces-1151C

528. Little C Loves 3 II (diff=2200, constructive algorithm)
Pattern finding, no magic. https://codeforces.com/problemset/problem/1034/B

529. Ehab's REAL Number Theory Problem (diff=2600, observation, BFS cycle finding)
There are several key observations that would lead to an essential template problem. Firstly, since every
number has at most 7 divisors, we can easily show that each number has at most 2 prime factor. Then, the problem
is changed to the following, select a set of numbers such that the combined prime factors of the selected set
of numbers occur even number of times. Instead of thinking it as some kind of undoable NP problems, we use
the standard trick. Each number can be represented as an edge connecting the 2 primes (or 1 and itself).
Then, we want to find the smallest cycle inside the graph. Then, another observation is since each number
is less than 1e6, we only need to consider the cycle with prime less than 1e3 as starting point.
So, we could formulate the problem as follows, find the smallest cycle for all vertices that are prime and
less than 1000, this is a template BFS problem and would lead to the solve of this problem.
https://codeforces.com/problemset/problem/1325/E

530. Recover the String (diff=1900, constructive algorithm)
First find number of 0, number of 1, then greedily construct. https://vjudge.net/problem/CodeForces-708B

531. Break Up (diff=2600, tarjan's bridge finding algorithm)
This problem should be extremely simple if c=1. The answer would be either 0 or the smallest bridge in the graph.
Then, let's think how to extend the result into c=2. There are several observations, 1) we only need to 
consider the edges that are in the biconnected components from s to t in the compressed graph. 2) If we pick
any path from s to t, at least one edge on this path should be eliminated. 3) The path length <= 1000. 4)
When we eliminate an edge on this path, all the bridges that are on the path from s to t in the graph (after the
edge is removed) are useful. Based on these 4 observations, we would solve the problem in O(nm).
https://vjudge.net/problem/CodeForces-700C

532. Queue (diff=1800, constructive algorithm)
Similar to another construction problem. Firstly, fix the order of students, then fill in height.
https://vjudge.net/problem/CodeForces-141C

533. Magic Stones (diff=2200, constructive algorithm)
Firstly, the first/last number cannot be changed. Secondly, we observe that the difference set cannot be changed.
https://vjudge.net/problem/CodeForces-1110E

534. Divide Points (diff=2300, constructive algorithm)
When we are dealing with distance/partition problems, odd/even partition is something we should always try.
https://vjudge.net/problem/CodeForces-1270E

535. Restore a Number (diff=2300, constructive algorithm)
Case differentiation. https://codeforces.com/problemset/problem/670/F

536. Permutation recovery (diff=2100, constructive algorithm, line sweep, top-sort)
The first observation is if we treat (i, nxt[i]) as segments, if there's a partial overlap relationship
we must print -1. Then, we can construct a graph and run the top-sort algorithm. The only thing tricky
here is we cannot add all the edge in, we can only add O(n) many edges. But this is not very hard by
using the fact of total overlap between segments. https://vjudge.net/problem/CodeForces-1158C

537. Sonya and Ice Cream (diff=2400, tree diameter)
I'm quite excited that I can solve this problem after 8 months I saw it. The most important observation is
the k shops must be on the diameter of the tree. I guessed this because I solved 911F before, and this conclution
can easily be proved by contradiction. Then, let's think what the answer should be. Again, by using the
property of the diameter of the tree, we can see that it should be the A = maximum distance from
points not on the diameter to the diameter, B = when you place the chain of length k on the diameter,
the distance of endpoint 1 to the chain, C = when you place the chain of length k on the diameter,
the distance of endpoint 2 to the chain. A can be calculated by dijkstra. B and C can be calculated by sliding window. The answer would be max(min(B, C), A). https://vjudge.net/problem/CodeForces-1004E

538. Happy Line (diff=2200, constructive algortihm)
https://vjudge.net/problem/CodeForces-549G

539. Restore the Permutation by Sorted Segments (diff=2400, constructive algorithm)
This problem should be dealt with carefully. The easy observation we can fill in the numbers in a backward
direction. However, the only obstacle is there might be 2 candidate. But if we think this carefully, we should
realize that 2 candidate case should only happen once during the entire program. 
https://vjudge.net/problem/CodeForces-1343F

540. Tourists (diff=2600, line sweep, range tree)
I was ready to give up on this. When suddenly, I have an idea to deal with the trickiest case of this problem.
The problem can be formulated as follows, given many 45 degree segments, from (t-r, l) to (t-l, r).
You have to answer q queries, what's the total projection for the segments on x=q[i].
There is a very simple case, it is all the segments are not intersecting. We can deal with this by simiply
applying line sweep. But how to deal with the interection of segments? Here, we apply a trick. Since each
wall would stand there after it occurs, so that actually, if we discrete all the distinct y coordinates and
build a range min tree on it, each time we do something like update the earlist occurence of wall in range[l, r] to t. And after that instead of considering the origional segments, we can consider the modified set of
non-overlapping small segments, formed by adjacent y. This would solve the problem by applying the algorithm in
the simple case. https://vjudge.net/problem/CodeForces-286D

541. Biologist (diff=2300, min cut)
The hardest part on this problem is it has so many constraints. Firstly, it is not hard to observe this is 
a project selection type max flow problem. The key here is how to formulate all the constraints accuratly.
We partition the graph into 2 parts, left part all the plan with target 0 and all the dogs with sex 0.
Then, we can think this as all the dogs that want to avoid changing to sex 1 and all the plan that should 
avoid a dog in the set has sex 1. Hence, instead of calculating the max flow, let's use min cut to express
the minimum penalty that can be gained. A final trick is if a dog is shared by 2 different types of plan,
there's an edge with capacity INF between these 2 plans, because these plans cannot exist at the same time!
https://vjudge.net/problem/CodeForces-311E

542. The Feast and the Bus (diff=1800, constructive algorithm)
The only trick is justify brute force on s works.
https://vjudge.net/problem/CodeForces-1250B

543. Power Tree (diff=2500, MST, binary-lifting)
I'm very excited that I can solve this problem by myself. If we formulated this problem, we should know
this is equivalent to finding a basis for the leaf with the minimum cost. By the definition of basis,
it must contain |leaf| number of nodes and all the range cover of the nodes are linearly independent.
Here range cover [l, r] means the id of the leftmost leaf that's in the subtree and the rightmost leaf
that's in the subtree. There's a property of linearly dependent, if a group of vectors are linearly dependent
then there must be an index i such that the previous i-1 vector can combine to be i. Based on the special
property of leaf cover, we can solve this problem by using MST. It is add edges between [l, r+1], then
see which edge can appear in at least 1 MST. This is a standard MST problem, can be done with 
kruskal algorithm and binary-lifting. https://vjudge.net/problem/CodeForces-1120D

544. Swaps Again (diff=2100, constructive algorithm)
The intuition is we could sort from the middle, and we should know that a[i] and a[n-i+1] should always
occur as a pair, hence we only need to check whether the set formed by a[i], a[n-i+1] is the same as the
set formed by b[i], b[n-i+1] for all i. https://vjudge.net/problem/CodeForces-1365F

545. Number of Components (diff=2800, union find)
I hate this problem. The constraints were set to target the normal range tree on queries solution.
We should observe the following property, each color's add query occurs before all its delete query.
Hence, we can process color by color, add in forward order, delete in reverse order. The reason
for color by color works is also because of the constraints. So in conclusion, the constraints were
set to make sure only this solution work, even if this solution would not work if you remove any of the
constraints. https://codeforces.com/problemset/problem/1303/F

546. Lena and Queries (diff=2500, CHT-trick, range tree on queries)
We should immediately realize the range tree on queries trick. The only tricky part is the query part,
we can use descending on range tree to solve this. https://vjudge.net/problem/CodeForces-678F

547. Clearing Up (diff=2300, constructive algorithm, BFS, kruskal)
The problem is asking to find a spanning tree with half 0 edge and half 1 edge. We can firstly add in all the
0 edges, and then all the 1 edges using kruskal algorithm. Then, if |0| < |1| no solution. Otherwise,
we add in the remaining 1-edge 1 by 1, each time use BFS to find a 0-edge on the shortest path of the two end
points and eliminate that edge. https://vjudge.net/problem/CodeForces-141E

548. Session in BSU (diff=2400, union find)
This is a very neat problem, even if I failed to solve it by myself. The key here is to jump out of the box.
We shouldn't think flow is the only way of solving this kind of problem. Observe that if we join the 
2 days for each person by an edge, the days would be seperated into different connected components.
There are actually only 3 cases on these connected components, a tree, a functional graph, some other graph.
We could easily check the following claim is true, for a tree the answer is the second largest date,
for a functional graph, the answer is the largest date, and if any other graph occurs in any of the 
connected components, there's no solution, by pigeon hole princinple.
https://vjudge.net/problem/CodeForces-1027F


549. Road Widening (diff=1800, constructive algorithm)
We can formulate this problem as n inequalities and the x solved by each inequality should satisfy the adjacent x
differs no more than 1. https://vjudge.net/problem/CodeForces-883K

550. Short Colorful Strip (diff=2200, interval dp)
https://vjudge.net/problem/CodeForces-1178F1

551. Ralph And His Magic Field (diff=1800, constructive algorithm)
Very simple if you've solved 1016D before. https://vjudge.net/problem/CodeForces-894B

552. Points, Lines and Ready-made Titles (diff=2300, union-find)
This is a problem that stucked me for a long time. The most important observation is we try to think the "component" of a painting.
There are 2 types of components, horizontal lines and vertical lines. If all of the components can appear at the same time,
the total number of painting would simply be 2^|x| * 2^|y|. We firstly apply union find to join points with the same x/y coordinate
then, if a connected component has a cycle, we simply use the above formula to calculate the answer, otherwise, the answer is
given by 2^(sz + 1) - 1. We should multiply the contribution of each connected component together to get our final answer.
https://vjudge.net/problem/CodeForces-870E

553. New Year and Castle Construction (diff=2500, geometry)
This problem is very hard to come up with the correct idea. Intead of calculating how many castles in total, we can subtract
the number of invalid set of 4 points for each point. If 4 points cannot shelter another vertex v, it must occur on the same side.
Then, the problem is changed into a typical sorting by polar angle problem. https://vjudge.net/problem/CodeForces-1284E

554. The Untended Antiquity (diff=2400, 2d-fenwick tree, hashing)
This problem is a bit weird. Firstly, we note that two cells can reach each other if the rectangles cover on these 2 cells are exactly 
the same. Hence, we want to sum up the "id" of the rectangle grids covered on these two points and check whether they are the same.
This "id" can be done by using hashing. Strange problem :(. https://vjudge.net/problem/CodeForces-869E

555. DayAndNight (min-cut)
The greatest legacy left by Ray. https://vjudge.net/problem/TopCoder-14687

556. Irrigation (diff=2200, line sweep)
This problem seems very simple right now after I solved huge amount of similar problems.
https://vjudge.net/problem/CodeForces-1181D

557. Flawed Flow (diff=2100, constructive algorithm)
The key observation is, for all the nodes except 1 and n, the netflow through each vertices must be 0, which is the incoming
flow is equal to the outgoing flow. And another thing is, if we do a BFS procedure and stand at a node that has been balanced,
there must be a node in its successor such that the after we direct the edge in between the netflow of that successor is also 0.
Such vertices must exist, because the graph is a DAG. https://vjudge.net/problem/CodeForces-269C

558. Scaygerboss (diff=2800, binary search on final answer, maxflow)
The fact that this is a matching problem should be quite obvious. And for these kind of graph based max flow problems, the 
most standard trick is using binary search on final answer and check full flow. We build the graph in this way, man on LHS,
position with vertex capacity 1 in the middle and female on the other side.
https://codeforces.com/contest/513/problem/F2

559. New Year Tree (diff=2400, tree diameter, binary-lifting)
Learned something new on tree diameter. There's a key property on tree diameter, every vertex's furthest point must be on at
least 1 tree diameter. https://vjudge.net/problem/CodeForces-379F

560. Destroying Roads (diff=2100, BFS)
Observe that the optimal construction should look like s1->(common roads)->t1, s2->(common roads)->t2, we can simply manipulate
all the possible end points of the common roads. https://vjudge.net/problem/CodeForces-543B

561. Catowice City (diff=2400, tarjan's scc algorithm, 2-sat)
We can easily formulate this problem as a 2-sat problem. For a constraint that jury A and cat B (let's say jury ~B) are not in the
same set. We can write it as ~A | ~~B, which is A -> B, thus we can add an edge between jury A and jury B for these constraints.
The solution exists iff the number of scc in the graph in more than 1.
https://codeforces.com/contest/1239/problem/D

562.  Natasha, Sasha and the Prefix Sums (diff=2300, dp)
The lesson I learned from this problem is, combinatorics problems should be solved by calculating contributions.
https://codeforces.com/problemset/problem/1204/E

563. Binary Subsequence Rotation (diff=2100, greedy)
The observation is we can treat (1, 0) as 1 and (0, 1) as -1, and the answer is the maximum absolute value subarray.
https://codeforces.com/contest/1370/problem/E

564. The Hidden Pair (Easy Version) (diff=2400, binary search, dfs)
The observation is if we firstly query all the points, we can get a point on the (u, v) path. Then, we use that point,
and do binary search to find one of the end point u/v. Then, we use the distance on the tree to fix the other u/v.
The maximum number of queries for this approach is 12. Hence, it can solve the easy version with a query limit 14, but
not the hard one with a query limit 11. https://vjudge.net/problem/CodeForces-1370F1

565. The Hidden Pair (Hard Version) (diff=2700, binary search, dfs, observation)
The cored of the algorithm isn't changed. We actually just need to reduce 1 query. Think amout how HLD works, we should know
that if we let the point we get after the first query as root, by setting low = d/2, we can still get the downward nodes.
This would reduce the binary search time by 1, hence solve the general version of the problem. 
https://vjudge.net/problem/CodeForces-1370F2

566. Deduction Queries (diff=2400, union find)
This is a quite weird problem. Firstly, and obviously, we should write xor[l, r] as p[l-1] xor p[r] which p is the xor prefix sum.
Then, the next observation is we can use union find to maintain related ids. This is because p[a] is known p[b] is known
p[a] xor p[b] must be known, due to the transitivity of xor. https://codeforces.com/problemset/problem/1044/D

567. Special Matrices (diff=2100, dp)
Quite standard trick. https://vjudge.net/problem/CodeForces-489F

568. The Doctor Meets Vader (Hard) (diff=2700, min cut, line sweep, floyd algorithm)
The natrual idea is we observe that the base are actually independent from the spaceship, every spaceship can attack the base
that would bring the maximum profit. So the first subproblem of this one is as follows, each spaceship has an attacking range,
find the maximum profit such that the base is within its attacking range and has a defence no more than its 'a' value.
This can be done by preprocessing all pair shortest path and solve the queries using line sweep. I would ignore the details because
it is sooooo standard. Secondly, we observe that these profits (+/-) have dependencies. It is if you select a profit, you must select
another one. This is the typical maximum enclosure graph model. Which can be solved by connect s to all the + profit nodes and t
to all the - profit nodes and add the forced edge with INF capacity. Something we should be careful is, k is less than 1000, so that
the "important spaceship" is less than 2000. If a spaceship has no constraints on it and it has positive cost, just add it to the answer,
don't include it into the flow graph. This would reduce the number of nodes from 1e5 to 2e3, which is a huge improvement to run time.
https://codeforces.com/problemset/problem/1184/B3

569. Heidi and Library (hard) (diff=2600, MCMF)
I had some initial observations on this problem, we can firstly purchase all the books in and minus the merging cost (i.e. the 
book of the same type that is required on day d1 and d2 can be calculated only once). But what happened next to this problem is
stunning. The flow graph works like this, each vertex is splitted into 2 nodes i and i'. Then we add edges (1, cost) from src to i
and edges (1, 0) from i' to sink. Then, we add edges from i to i' (1, 0). To make sure each day there's only k books in hand, we
can add edges (k-1, 0) from i to i+1. And to deal with the merging cost condition, we can add edges from i-1 to j' (1, -cost[tp[i]]).
Here j' is the outgoing vertices such that tp[i] = tp[j] and j is the maximum of those nodes (j < i). The MCMF would be the answer.
The key lesson for this problem is how to model the k books in hand condition.
https://codeforces.com/problemset/problem/802/C

570. Bits of merry old England (diff=2700, MCMF)
Exactly the same as the previous problem, just use line sweep to extract the flow.
https://vjudge.net/problem/CodeForces-132E

571. Putting Boxes Together (diff=2500, range tree, binary search)
This problem is routine right now. But just be careful about taking mods, you cannot take mods on W[i]. 
https://vjudge.net/problem/CodeForces-1030F


572. Vladik and Favorite Game (diff=2100, constructive algorithm, BFS)
Very easy. Just do a BFS and walk along the path, if we realize we are moving towards the opposite direction,
we swap the corresponding symbols. https://vjudge.net/problem/CodeForces-811D

573. Ehab's Last Theorem (diff=2500, dfs maximum cycle finding)
If we can find the maximum cycle and it is greater than sqrt(n), then we can have solution of second type. However, if
we don't have such thing, it doesn't mean the job we done are useless. It means that if we partition our tree according to
height % (sqrt(n) - 1), the maximum chunk is an independent set. 
https://vjudge.net/problem/CodeForces-1325F

574. Xenia and Tree (diff=2400, sqrt decomposition)
This problem is so interesting. We can process the updates in sqrt blocks. If the unprocessed updates exceeds sqrt(m), we do
a multisource BFS and update our dist value, otherwise, the answer is given by the shortest distance to our unprocessed nodes,
this can be done by sparse table and LCA. https://vjudge.net/problem/CodeForces-342E

575. Subset Sums (diff=2500, sqrt decomposition)
This problem is a bit unexpected. We should realize that two types of operations are actually operated on non-consecutive segments,
hence range tree/line sweep in general cannot be used. Type 2 operation can be done quickly if the updates are tagged on the 
corresponding sets. However, this would affect the ? query. Let's think how to make use of the tag idea. We divide the sets into
heavy and light, heavy sets have more than sqrt(n) many elements, while light sets have less than that amount. Then, for the heavy
set updates, we simply apply the tag operation, and for the light set operation, we simply updates using brute force. The 
algorithm works because the the number of intersection sets each heavy sets can have is O(sqrt(n)), and the same for light set.
Another tricky thing is amout the implementation, be careful about the invariant of your data structure. 
https://vjudge.net/problem/CodeForces-348C

576. Ehab's Last Corollary (diff=2100, constructive algorithm)
This problem used the property of dfs, and the definition of backedge. With the experience of 1325F, solving this problem
should be simple enough. https://vjudge.net/problem/CodeForces-1364D

